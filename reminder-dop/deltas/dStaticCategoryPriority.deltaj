delta dStaticCategoryPriority {
	modifies br.unb.cic.reminders.model.db.DBConstants {
		removes CREATE_TABLE_STATEMENTS;
		adds public static String CREATE_TABLE_STATEMENTS[] = { "CREATE TABLE CATEGORY("
			+ "PK INTEGER PRIMARY KEY AUTOINCREMENT, " + "NAME VARCHAR(50) NOT NULL, " + "LOCKED INT NOT NULL);",

			"CREATE TABLE REMINDER ( " + "PK INTEGER PRIMARY KEY AUTOINCREMENT, " + "TEXT VARCHAR(50) NOT NULL,"
					+ "DETAILS VARCHAR(50) NULL,"
					+ "FK_CATEGORY INTEGER NOT NULL REFERENCES CATEGORY ON DELETE CASCADE," + "DATE CHAR(10) NULL,"
					+ "HOUR CHAR(5) NULL," + "PRIORITY INTEGER NOT NULL," + "DONE INTEGER NOT NULL);", };
		removes SELECT_REMINDERS;
		adds public static final String SELECT_REMINDERS = "SELECT PK, TEXT, DETAILS, FK_CATEGORY, DATE, HOUR, PRIORITY, DONE FROM REMINDER";
		removes SELECT_REMINDERS_BY_CATEGORY;
		adds public static final String SELECT_REMINDERS_BY_CATEGORY = "SELECT PK, TEXT, DETAILS, FK_CATEGORY, DATE, HOUR, PRIORITY, DONE FROM REMINDER " 
			+ "WHERE FK_CATEGORY = ?";
	}
	modifies br.unb.cic.reminders.model.cp.ReminderContentProvider {
		removes insert(Uri uri, ContentValues values);
		adds @Override public Uri insert(Uri uri, ContentValues values) {
			try {
				Reminder reminder = new Reminder();

				Category category = cdao.findCategory(values.getAsString(category()));
				reminder.setCategory(category);
				reminder.setText(values.getAsString(text()));
				reminder.setDate(values.getAsString(date()));
				reminder.setHour(values.getAsString(hour()));

				Long id = rdao.saveReminder(reminder);
				getContext().getContentResolver().notifyChange(uri, null);
				return Uri.parse(BASE_PATH + "/" + id);
			} catch (DBException e) {
				throw new RuntimeException(e.getLocalizedMessage());
			}

		}
	}
	modifies br.unb.cic.reminders.view.ExternalAddReminderActivity {
		removes setReminderFromIntent();
		adds private void setReminderFromIntent() throws Exception {
			Intent intent = getIntent();
			String action = intent.getAction();
			String type = intent.getType();
	
			// Gets the information from the intent if it is an edit call
			if (action.equals("br.com.positivo.reminders.ADD_REMINDER") && "text/plain".equals(type)) {
				String text = intent.getStringExtra("text");
				String details = intent.getStringExtra("details");
				String categoryName = intent.getStringExtra("category_name");
				String date = intent.getStringExtra("date");
				String hour = intent.getStringExtra("hour");
				String priority = intent.getStringExtra("priority");
	
				List<Category> categories = Controller.instance(getApplicationContext()).listCategories();
				for (Category c : categories) {
					if (c.getName().equals(categoryName)) {
						newCategory = c;
						break;
					}
				}
				reminder.setText(text);
				reminder.setDetails(details);
				reminder.setDate(date);
				reminder.setHour(hour);
				reminder.setPriority(Priority.fromCode(Integer.parseInt(priority)));
				reminder.setCategory(newCategory);
			} else
				reminder = null;
	
		}
		removes initializeValues();
		adds @Override protected void initializeValues() {
	
			if (!reminder.isValid())
				return;
	
			edtReminder.setText(reminder.getText());
			edtDetails.setText(reminder.getDetails());
			updateSpinnerDateHour(spinnerDate, reminder.getDate());
			updateDateFromString(reminder.getDate());
			updateSpinnerDateHour(spinnerTime, reminder.getHour());
			updateTimeFromString(reminder.getHour());
			spinnerPriority.setSelection(reminder.getPriority());
			try {
				spinnerCategory.setSelection(categoryToIndex(reminder.getCategory()));
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
	
		}
	}
	modifies br.unb.cic.reminders.model.db.DefaultReminderDAO {
		removes cursorToReminder(Cursor cursor);
		adds private Reminder cursorToReminder(Cursor cursor) throws DBException {
			Long pk = cursor.getLong(cursor.getColumnIndex(DBConstants.REMINDER_PK_COLUMN));
			String text = cursor.getString(cursor.getColumnIndex(DBConstants.REMINDER_TEXT_COLUMN));
			String details = cursor.getString(cursor.getColumnIndex(DBConstants.REMINDER_DETAILS_COLUMN));
			String date = cursor.getString(cursor.getColumnIndex(DBConstants.REMINDER_DATE_COLUMN));
			String hour = cursor.getString(cursor.getColumnIndex(DBConstants.REMINDER_HOUR_COLUMN));
			int priority = cursor.getInt(cursor.getColumnIndex(DBConstants.REMINDER_PRIORITY_COLUMN));
			int done = cursor.getInt(cursor.getColumnIndex(DBConstants.REMINDER_DONE_COLUMN));
			Long categoryId = cursor.getLong(cursor.getColumnIndex(DBConstants.REMINDER_FK_CATEGORY_COLUMN));
	
			Category category = DBFactory.factory(context).createCategoryDAO().findCategoryById(categoryId);
	
			Reminder reminder = new Reminder();
	
			reminder.setText(text);
			reminder.setDetails(details);
			reminder.setId(pk);
			reminder.setDate(date);
			reminder.setHour(hour);
			reminder.setPriority(Priority.fromCode(priority));
			reminder.setDone(done);
			reminder.setCategory(category);
	
			return reminder;
		}
	}
	modifies br.unb.cic.reminders.model.Reminder {
		removes isValid();
		adds public boolean isValid() {
			return (text != null && category != null && date != null && hour != null && priority != null);
		}
	}
	modifies br.unb.cic.reminders.view.EditReminderActivity {
		removes initializeValues();
		adds @Override protected void initializeValues() {
			Intent intent = getIntent();

			// Gets the information from the intent if it is an edit call
			long reminderId = intent.getLongExtra("id", 0);
			String text = intent.getStringExtra("text");
			String details = intent.getStringExtra("details");
			String categoryName = intent.getStringExtra("category_name");
			String categoryId = intent.getStringExtra("category_id");
			String date = intent.getStringExtra("date");
			String hour = intent.getStringExtra("hour");
			String priority = intent.getStringExtra("priority");

			Category category = new Category();
			category.setId(Long.parseLong(categoryId));
			category.setName(categoryName);

			reminder.setId(reminderId);
			edtReminder.setText(text);
			edtDetails.setText(details);
			updateSpinnerDateHour(spinnerDate, date);
			updateDateFromString(date);
			updateSpinnerDateHour(spinnerTime, hour);
			updateTimeFromString(hour);
			spinnerPriority.setSelection(Priority.fromCode(Integer.parseInt(priority, 10)).getCode());
			try {
				spinnerCategory.setSelection(categoryToIndex(category));
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
	modifies br.unb.cic.reminders.view.FilterListFragment {
		adds import br.unb.cic.reminders.controller.PriorityFilter;
		adds import br.unb.cic.reminders.model.Priority;
		removes  updateListView();
		adds private void updateListView() {

			List<ReminderFilter> filters = new ArrayList<ReminderFilter>();

			// Add the allReminders to the filter list
			AllRemindersFilter allRemindersFilter = new AllRemindersFilter(getActivity());
			filters.add(allRemindersFilter);

			// Add the priorities to the filter list
			PriorityFilter highPriorityFilter = new PriorityFilter(Priority.HIGH, getActivity());
			filters.add(highPriorityFilter);
			PriorityFilter normalPriorityFilter = new PriorityFilter(Priority.NORMAL, getActivity());
			filters.add(normalPriorityFilter);
			PriorityFilter lowPriorityFilter = new PriorityFilter(Priority.LOW, getActivity());
			filters.add(lowPriorityFilter);

			// Get all categories
			List<Category> categories = new ArrayList<Category>();
			try {
				categories = Controller.instance(getActivity().getApplicationContext()).listCategories();
				notifyListeners(null);
			} catch (DBException e) {
				Log.e(CURRENT_FILTER_KEY, "STORAGE_SERVICE error. Message: " + e.getMessage()); // TODO:
																								// Handle
																								// it
																								// properly.
				e.printStackTrace();
			} catch (Exception e) {
				Log.e(CURRENT_FILTER_KEY, "STORAGE_SERVICE error. Message: " + e.getMessage()); // TODO:
																								// Handle
																								// it
																								// properly.
				e.printStackTrace();
			}

			// Add the categories to the filter list
			ReminderFilter filter;
			for (Category c : categories) {
				filter = new CategoryFilter(c, getActivity());
				filters.add(filter);
			}

			adapter = new ReminderFilterArrayAdapter(getActivity().getApplicationContext(), filters);

			lvFilters.setAdapter(adapter);
		}
	}
	modifies br.unb.cic.reminders.view.ReminderListFragment {
		removes onContextItemSelected(MenuItem item);
		adds @Override public boolean onContextItemSelected(MenuItem item) {
			if (item.getGroupId() == R.id.context_menu_reminder) { // Used to verify
				// if it is the right context_menu
	
				// Gets the item position and gets the reminder in that position:
				AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
				Reminder reminder = (Reminder) contextMenuAdapter.getItem(info.position);
	
				// Switch between the options in the context menu(Edit, Delete and
				// Share)
				switch (item.getItemId()) {
				case R.id.edit:
					// Passes the current reminder to be edited via Intent and
					// Invokes edit method
					Intent editIntent = new Intent(getActivity().getApplicationContext(), EditReminderActivity.class);
					editIntent.putExtra("id", reminder.getId());
					editIntent.putExtra("text", reminder.getText());
					editIntent.putExtra("details", reminder.getDetails());
					editIntent.putExtra("category_name", reminder.getCategory().getName());
					editIntent.putExtra("category_id", Long.toString(reminder.getCategory().getId()));
					editIntent.putExtra("date", reminder.getDate());
					editIntent.putExtra("hour", reminder.getHour());
					editIntent.putExtra("priority", Integer.toString(reminder.getPriority()));
					startActivity(editIntent);
					updateListView(null);
					return true;
				case R.id.delete:
					// Invokes delete method
					try {// Deletes from the bank;
						Controller.instance(getActivity().getApplicationContext()).deleteReminder(reminder);
					} catch (DBException e) {
						Log.e(TAG, e.getMessage());
					}
					updateListView(null);
					return true;
				default:
					return super.onContextItemSelected(item);
				}
	
			}
			return super.onContextItemSelected(item);
		}
	}
	modifies br.unb.cic.reminders.view.ReminderActivity {
		removes createReminder();
		adds private void createReminder() {
			try {
				reminder.setText(edtReminder.getText().toString());
				reminder.setDetails(edtDetails.getText().toString());
				reminder.setDate(dateToString());
				reminder.setHour(timeToString());
				reminder.setPriority(selectedPriority);
				reminder.setCategory((Category) spinnerCategory.getSelectedItem());
			} catch (InvalidTextException e) {
				// This catch is handling both Reminder's Text and Details.
				Toast.makeText(getApplicationContext(), "Invalid text.", Toast.LENGTH_SHORT).show();
			} catch (InvalidDateException e) {
				Toast.makeText(getApplicationContext(), "Invalid date.", Toast.LENGTH_SHORT).show();
			} catch (InvalidHourException e) {
				Toast.makeText(getApplicationContext(), "Invalid time.", Toast.LENGTH_SHORT).show();
			} catch (Exception e) {
				// this is an exceptional case that needs to be studied
				Toast.makeText(getApplicationContext(), "Serious error.", Toast.LENGTH_SHORT).show();
			}
		}
	}
	modifies br.unb.cic.reminders.view.ReminderAddActivity {
		removes createReminder();
		adds private Reminder createReminder() {
			/*
			 * Since view's not passing all the information yet (priority ...), we
			 * instantiate a reminder initially passing only "text" and "date".
			 */
			Reminder reminder = new Reminder();
			try {
				reminder.setText(edtReminder.getText().toString());
				reminder.setDetails(edtDetails.getText().toString());
				reminder.setDate(edtDate.getText().toString());
				reminder.setHour(edtHour.getText().toString());
				reminder.setCategory(selectedCategory);
				reminder.setPriority(selectedPriority);
			} catch (InvalidTextException e) {
				Toast.makeText(getApplicationContext(), "Invalid text.", Toast.LENGTH_SHORT).show();
			} catch (InvalidDateException e) {
				Toast.makeText(getApplicationContext(), "Invalid date.", Toast.LENGTH_SHORT).show();
			} catch (InvalidHourException e) {
				Toast.makeText(getApplicationContext(), "Invalid time.", Toast.LENGTH_SHORT).show();
			}
			return reminder;
		}
		removes getExistingReminder();
		adds private Reminder getExistingReminder() {
			Reminder reminder = null;
	
			Intent intent = getIntent();
			String action = intent.getAction();
			String type = intent.getType();
	
			// Gets the information from the intent if it is an edit call
			if (Intent.ACTION_SEND.equals(action) && "text/plain".equals(type)) {
				previewReminderId = intent.getLongExtra("id", 0);
				String text = intent.getStringExtra("text");
				String categoryName = intent.getStringExtra("category_name");
				String categoryId = intent.getStringExtra("category_id");
				String date = intent.getStringExtra("date");
				String hour = intent.getStringExtra("hour");
				String priority = intent.getStringExtra("priority");
	
				reminder = new Reminder();
				reminder.setText(text);
				reminder.setPriority(Priority.fromCode(Integer.parseInt(priority, 10)));
				Category category = new Category();
				category.setName(categoryName);
				category.setId(Long.parseLong(categoryId));
				reminder.setCategory(category);
				reminder.setDate(date);
				reminder.setHour(hour);
				reminder.setId(previewReminderId);
			}
	
			return reminder;
		}
		removes getReminderFromIntent();
		adds private Reminder getReminderFromIntent() {
			Intent intent = getIntent();
			String action = intent.getAction();
			String type = intent.getType();
	
			/*
			 * External apps which wants to share content with "Lembretes" must
			 * follow the protocol described by the "if" below, that is, they must
			 * instantiate an intent and set:
			 * 
			 * ACTION as "br.com.positivo.reminders.ADD_REMINDER"; MIME as
			 * "text/plain";
			 * 
			 * and pass the contents through "putExtra" in the following fields:
			 * "text", "details", "category", "date", "hour" and "priority".
			 */
			if ("br.com.positivo.reminders.ADD_REMINDER".equals(action) && "text/plain".equals(type)) {
				try {
					String text = intent.getStringExtra("text");
					String details = intent.getStringExtra("details");
					String category = intent.getStringExtra("category");
					String date = intent.getStringExtra("date");
					String hour = intent.getStringExtra("hour");
					String priority = intent.getStringExtra("priority");
	
					/*
					 * Code below just validates the data supplied, since validation
					 * code is implemented in setter methods.
					 */
	
					// Would we better apply validations here?
					Reminder reminder = new Reminder();
					reminder.setText(text);
					reminder.setDetails(details);
	
					Category auxCategory = new Category();
					auxCategory.setName(category);
					reminder.setCategory(auxCategory);
	
					reminder.setDate(date);
					reminder.setHour(hour);
	
					/*
					 * Upon here, all validations were applied and we have a valid
					 * reminder. So, we return it.
					 */
					return reminder;
				} catch (InvalidFormatException e) {
					/*
					 * What would be better? 1. Return user to the calling activity.
					 * 2. Show an empty reminder's add form (implemented now).
					 */
				}
			}
			/*
			 * If this activity was not started from an external app or a valid
			 * reminder could not be derived, we simply return "null".
			 */
			return null;
		}
		removes initialize(Reminder reminder);
		adds private void initialize(Reminder reminder) {
			try {
				edtReminder = (EditText) findViewById(R.id.edtReminder);
	
				edtDetails = (EditText) findViewById(R.id.edtDetails);
	
				// edtDate = (EditText) findViewById(R.id.edtDate);
				// edtDate.addTextChangedListener(Mask.insert("##-##-####",
				// edtDate));
	
				// edtHour = (EditText) findViewById(R.id.edtHour);
				// edtHour.addTextChangedListener(Mask.insert("##:##", edtHour));
	
				spinnerPriority = getSpinnerPriority();
	
				spinnerCategory = getSpinnerCategory();
	
				if (reminder != null) {
					updateFieldsFromReminder(reminder);
				}
	
				btnSave = (Button) findViewById(R.id.btnSave);
				btnCancel = (Button) findViewById(R.id.btnCancel);
			} catch (Exception e) {
				// TODO: we really need to think about our exception handling
				// approach
				e.printStackTrace();
			}
		}
	}
}