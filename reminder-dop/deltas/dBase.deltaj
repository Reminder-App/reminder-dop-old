delta dBase {
	adds {
		package br.unb.cic.reminders;

		import android.app.Activity;
		import android.app.FragmentTransaction;
		import android.content.Intent;
		import android.os.Bundle;
		import android.view.Menu;
		import android.view.MenuInflater;
		import android.view.MenuItem;
		import br.unb.cic.reminders.view.AddReminderActivity;
		import br.unb.cic.reminders.view.FilterListFragment;
		import br.unb.cic.reminders.view.ReminderListFragment;
		import br.unb.cic.reminders2.R;
		
		public class ReminderMainActivity extends Activity {
		
			private static String TAG = "lembretes";
		
			/**
			 * Called when the activity is first created.
			 * 
			 * @param savedInstanceState
			 *            If the activity is being re-initialized after previously being
			 *            shut down then this Bundle contains the data it most recently
			 *            supplied in onSaveInstanceState(Bundle). <b>Note: Otherwise it
			 *            is null.</b>
			 */
			@Override
			protected void onCreate(Bundle savedInstanceState) {
				super.onCreate(savedInstanceState);
				setContentView(R.layout.reminders_main_activity);
				createUI();
			}
		
			/**
			 * Creates the User Interface. Creates the ListFragment.
			 */
			private void createUI() {
				FragmentTransaction ft = getFragmentManager().beginTransaction();
				ReminderListFragment listReminderFragment = new ReminderListFragment();
				FilterListFragment listCategoryFragment = new FilterListFragment();
				listCategoryFragment.addListener(listReminderFragment);
				ft.add(R.id.listReminders, listReminderFragment);
				ft.add(R.id.listCategories, listCategoryFragment);
				ft.commit();
			}
		
			/**
			 * Create Options Menu. Creates the buttons on the ActionBar.
			 */
			@Override
			public boolean onCreateOptionsMenu(Menu menu) {
				MenuInflater inflater = getMenuInflater();
				inflater.inflate(R.menu.action_bar_menu, menu);
				return true;
			}
		
			/**
			 * Switch between the buttons in the options menu.
			 */
			@Override
			public boolean onOptionsItemSelected(MenuItem item) {
				switch (item.getItemId()) {
				case R.id.menu_addReminder:
					// app icon in action bar clicked; go home
					Intent reminderIntent = new Intent(getApplicationContext(), AddReminderActivity.class);
					startActivity(reminderIntent);
					return true;
				case R.id.menu_searchReminder:
					return true;
				default:
					return super.onOptionsItemSelected(item);
				}
			}
		
		}
	}
	adds {
		package util;
		
		import java.text.ParseException;
		import java.text.SimpleDateFormat;
		import java.util.Date;
		import java.util.Locale;
		
		public class DateFormat {
			/*
			 * Static function that formats the database readable date into an object of
			 * type Date
			 */
			public static Date dateFormater(String dateUnformated) throws ParseException {
				SimpleDateFormat sdf = new SimpleDateFormat("dd-MM-yyyy HH:mm", Locale.getDefault());
				return sdf.parse(dateUnformated);
			}
			
		}
	}
	adds {
		package util;
		
		import android.text.Editable;
		import android.text.TextWatcher;
		import android.widget.EditText;
		
		/**
		 * Class used to mask the input of editTexts. For example for date:YYYY-MM-DD.
		 */
		public abstract class Mask {
		
			/**
			 * Unmasks a String;
			 */
			public static String unmask(String str) {
				return str.replaceAll("[:]", "").replaceAll("[.]", "").replaceAll("[-]", "").replaceAll("[/]", "")
						.replaceAll("[(]", "").replaceAll("[)]", "");
			}
		
			/**
			 * Inserts one mask to an EditText.
			 * 
			 * @param String
			 *            mask, EditText editText, the string is used to pass the format
			 *            of the mask through a string, for example "##-##-####" and the
			 *            EditText that will be watched and changed based in the mask.
			 */
			public static TextWatcher insert(final String mask, final EditText ediTxt) {
				return new TextWatcher() {
					boolean isUpdating;
					String old = "";
		
					public void onTextChanged(CharSequence s, int start, int before, int count) {
						String str = Mask.unmask(s.toString());
						String txt = "";
						if (isUpdating) {
							old = str;
							isUpdating = false;
							return;
						}
						int i = 0;
						boolean done = false;
						for (char m : mask.toCharArray()) {
							if (!done && m != '#' && str.length() > old.length()) {
								txt += m;
							} else if (!done && i < str.length()) {
								txt += str.charAt(i);
								i++;
							} else {
								done = true;
							}
						}
						isUpdating = true;
						ediTxt.setText(txt);
						ediTxt.setSelection(txt.length());
					}
		
					public void beforeTextChanged(CharSequence s, int start, int count, int after) {
					}
		
					public void afterTextChanged(Editable s) {
					}
				};
			}
		
		}
	}
	adds {
		package util;
		
		public class Patterns {
		
			// TODO: Fix TEXT_PATTERN to allow "." in the middle of text and not only in
			// the end of the sentence.
			public static final String TEXT_PATTERN = "[^.!?\\s][^.!?]*(?:[.!?](?![']?\\s|$)[^.!?]*)*[.!?]?[']?(?=\\s|$)";
		
			public static final String DATE_PATTERN = "(0[1-9]|[12][0-9]|3[01])[- /.](0[1-9]|1[012])[- /.](19|20)\\d\\d";
		
			public static final String HOUR_PATTERN = "([01]?[0-9]|2[0-3]):[0-5][0-9]";
		}
	}
	adds {
		package util;

		import android.view.View;
		import android.view.ViewGroup;
		import android.widget.ListAdapter;
		import android.widget.ListView;
		
		/**
		 * Created to give some general use functions.
		 * 
		 * @author rafaelsimao
		 */
		
		public class Utility {
		
			/**
			 * Rearrange the size of a ListView to its content size.
			 * 
			 * @param listView
			 */
			public static void setListViewHeightBasedOnChildren(ListView listView) {
				ListAdapter listAdapter = listView.getAdapter();
				if (listAdapter == null) {
					// pre-condition
					return;
				}
		
				int totalHeight = 0;
				for (int i = 0; i < listAdapter.getCount(); i++) {
					View listItem = listAdapter.getView(i, null, listView);
					listItem.measure(0, 0);
					totalHeight += listItem.getMeasuredHeight();
				}
		
				ViewGroup.LayoutParams params = listView.getLayoutParams();
				params.height = totalHeight + (listView.getDividerHeight()*(listAdapter.getCount() - 1));
				listView.setLayoutParams(params);
			}
		
		}
	}
	adds {
		package br.unb.cic.framework.persistence.annotations;

		import java.lang.annotation.ElementType;
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		import java.lang.annotation.Target;
		
		import br.unb.cic.framework.persistence.DBTypes;
		
		@Retention(RetentionPolicy.RUNTIME)
		@Target(ElementType.FIELD)
		public @interface Column {
			String column();
		
			boolean primaryKey() default false;
		
			DBTypes type();
		}
	}
	adds {
		package br.unb.cic.framework.persistence.annotations;
		
		import java.lang.annotation.ElementType;
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		import java.lang.annotation.Target;
		
		/**
		 * An interface to declare entity classes.
		 * 
		 * @author rbonifacio
		 */
		@Retention(RetentionPolicy.RUNTIME)
		@Target(ElementType.TYPE)
		public @interface Entity {
			String table();
		}
	}
	adds {
		package br.unb.cic.framework.persistence.annotations;
		
		import java.lang.annotation.ElementType;
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		import java.lang.annotation.Target;
		
		/**
		 * Used to map an attribute as a foreign key in the database.
		 * 
		 * @author rbonifacio
		 */
		@Retention(RetentionPolicy.RUNTIME)
		@Target(ElementType.FIELD)
		public @interface ForeignKey {
			String mappedBy();
		}
	}
	adds {
		package br.unb.cic.framework.persistence;
		
		/**
		 * Use to signal database exceptions.
		 * 
		 * @author rbonifacio.
		 */
		public class DBException extends Exception {
		
			private static final long serialVersionUID = 1L;
		
		}
	}
	adds {
		package br.unb.cic.framework.persistence;
		
		/**
		 * Exception that is thrown when an invalid Entity is identified by the
		 * persistence framework.
		 * 
		 * @author rbonifacio
		 */
		public class DBInvalidEntityException extends Exception {
		
			private static final long serialVersionUID = 1L;
		
			/**
			 * Constructor
			 * 
			 * @param e
			 *            the invalid entity
			 */
			public DBInvalidEntityException(Object e) {
				super(e.getClass().getCanonicalName() + "is not a valid entity according to the persistence framework.");
			}
		}
	}
}
