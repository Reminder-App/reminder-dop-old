delta dBase {
	adds {
		package br.unb.cic.reminders;

		import android.app.Activity;
		import android.app.FragmentTransaction;
		import android.content.Intent;
		import android.os.Bundle;
		import android.view.Menu;
		import android.view.MenuInflater;
		import android.view.MenuItem;
		import br.unb.cic.reminders.view.AddReminderActivity;
		import br.unb.cic.reminders.view.FilterListFragment;
		import br.unb.cic.reminders.view.ReminderListFragment;
		import br.unb.cic.reminders2.R;
		
		public class ReminderMainActivity extends Activity {
		
			private static String TAG = "lembretes";
		
			/**
			 * Called when the activity is first created.
			 * 
			 * @param savedInstanceState
			 *            If the activity is being re-initialized after previously being
			 *            shut down then this Bundle contains the data it most recently
			 *            supplied in onSaveInstanceState(Bundle). <b>Note: Otherwise it
			 *            is null.</b>
			 */
			@Override
			protected void onCreate(Bundle savedInstanceState) {
				super.onCreate(savedInstanceState);
				setContentView(R.layout.reminders_main_activity);
				createUI();
			}
		
			/**
			 * Creates the User Interface. Creates the ListFragment.
			 */
			private void createUI() {
				FragmentTransaction ft = getFragmentManager().beginTransaction();
				ReminderListFragment listReminderFragment = new ReminderListFragment();
				FilterListFragment listCategoryFragment = new FilterListFragment();
				listCategoryFragment.addListener(listReminderFragment);
				ft.add(R.id.listReminders, listReminderFragment);
				ft.add(R.id.listCategories, listCategoryFragment);
				ft.commit();
			}
		
			/**
			 * Create Options Menu. Creates the buttons on the ActionBar.
			 */
			@Override
			public boolean onCreateOptionsMenu(Menu menu) {
				MenuInflater inflater = getMenuInflater();
				inflater.inflate(R.menu.action_bar_menu, menu);
				return true;
			}
		
			/**
			 * Switch between the buttons in the options menu.
			 */
			@Override
			public boolean onOptionsItemSelected(MenuItem item) {
				switch (item.getItemId()) {
				case R.id.menu_addReminder:
					// app icon in action bar clicked; go home
					Intent reminderIntent = new Intent(getApplicationContext(), AddReminderActivity.class);
					startActivity(reminderIntent);
					return true;
				case R.id.menu_searchReminder:
					return true;
				default:
					return super.onOptionsItemSelected(item);
				}
			}
		
		}
	}
	adds {
		package util;
		
		import java.text.ParseException;
		import java.text.SimpleDateFormat;
		import java.util.Date;
		import java.util.Locale;
		
		public class DateFormat {
			/*
			 * Static function that formats the database readable date into an object of
			 * type Date
			 */
			public static Date dateFormater(String dateUnformated) throws ParseException {
				SimpleDateFormat sdf = new SimpleDateFormat("dd-MM-yyyy HH:mm", Locale.getDefault());
				return sdf.parse(dateUnformated);
			}
			
		}
	}
	adds {
		package util;
		
		import android.text.Editable;
		import android.text.TextWatcher;
		import android.widget.EditText;
		
		/**
		 * Class used to mask the input of editTexts. For example for date:YYYY-MM-DD.
		 */
		public abstract class Mask {
		
			/**
			 * Unmasks a String;
			 */
			public static String unmask(String str) {
				return str.replaceAll("[:]", "").replaceAll("[.]", "").replaceAll("[-]", "").replaceAll("[/]", "")
						.replaceAll("[(]", "").replaceAll("[)]", "");
			}
		
			/**
			 * Inserts one mask to an EditText.
			 * 
			 * @param String
			 *            mask, EditText editText, the string is used to pass the format
			 *            of the mask through a string, for example "##-##-####" and the
			 *            EditText that will be watched and changed based in the mask.
			 */
			public static TextWatcher insert(final String mask, final EditText ediTxt) {
				return new TextWatcher() {
					boolean isUpdating;
					String old = "";
		
					public void onTextChanged(CharSequence s, int start, int before, int count) {
						String str = Mask.unmask(s.toString());
						String txt = "";
						if (isUpdating) {
							old = str;
							isUpdating = false;
							return;
						}
						int i = 0;
						boolean done = false;
						for (char m : mask.toCharArray()) {
							if (!done && m != '#' && str.length() > old.length()) {
								txt += m;
							} else if (!done && i < str.length()) {
								txt += str.charAt(i);
								i++;
							} else {
								done = true;
							}
						}
						isUpdating = true;
						ediTxt.setText(txt);
						ediTxt.setSelection(txt.length());
					}
		
					public void beforeTextChanged(CharSequence s, int start, int count, int after) {
					}
		
					public void afterTextChanged(Editable s) {
					}
				};
			}
		
		}
	}
	adds {
		package util;
		
		public class Patterns {
		
			// TODO: Fix TEXT_PATTERN to allow "." in the middle of text and not only in
			// the end of the sentence.
			public static final String TEXT_PATTERN = "[^.!?\\s][^.!?]*(?:[.!?](?![']?\\s|$)[^.!?]*)*[.!?]?[']?(?=\\s|$)";
		
			public static final String DATE_PATTERN = "(0[1-9]|[12][0-9]|3[01])[- /.](0[1-9]|1[012])[- /.](19|20)\\d\\d";
		
			public static final String HOUR_PATTERN = "([01]?[0-9]|2[0-3]):[0-5][0-9]";
		}
	}
	adds {
		package util;

		import android.view.View;
		import android.view.ViewGroup;
		import android.widget.ListAdapter;
		import android.widget.ListView;
		
		/**
		 * Created to give some general use functions.
		 * 
		 * @author rafaelsimao
		 */
		
		public class Utility {
		
			/**
			 * Rearrange the size of a ListView to its content size.
			 * 
			 * @param listView
			 */
			public static void setListViewHeightBasedOnChildren(ListView listView) {
				ListAdapter listAdapter = listView.getAdapter();
				if (listAdapter == null) {
					// pre-condition
					return;
				}
		
				int totalHeight = 0;
				for (int i = 0; i < listAdapter.getCount(); i++) {
					View listItem = listAdapter.getView(i, null, listView);
					listItem.measure(0, 0);
					totalHeight += listItem.getMeasuredHeight();
				}
		
				ViewGroup.LayoutParams params = listView.getLayoutParams();
				params.height = totalHeight + (listView.getDividerHeight()*(listAdapter.getCount() - 1));
				listView.setLayoutParams(params);
			}
		
		}
	}
	adds {
		package br.unb.cic.framework.persistence.annotations;

		import java.lang.annotation.ElementType;
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		import java.lang.annotation.Target;
		
		import br.unb.cic.framework.persistence.DBTypes;
		
		@Retention(RetentionPolicy.RUNTIME)
		@Target(ElementType.FIELD)
		public @interface Column {
			String column();
		
			boolean primaryKey() default false;
		
			DBTypes type();
		}
	}
	adds {
		package br.unb.cic.framework.persistence.annotations;
		
		import java.lang.annotation.ElementType;
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		import java.lang.annotation.Target;
		
		/**
		 * An interface to declare entity classes.
		 * 
		 * @author rbonifacio
		 */
		@Retention(RetentionPolicy.RUNTIME)
		@Target(ElementType.TYPE)
		public @interface Entity {
			String table();
		}
	}
	adds {
		package br.unb.cic.framework.persistence.annotations;
		
		import java.lang.annotation.ElementType;
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		import java.lang.annotation.Target;
		
		/**
		 * Used to map an attribute as a foreign key in the database.
		 * 
		 * @author rbonifacio
		 */
		@Retention(RetentionPolicy.RUNTIME)
		@Target(ElementType.FIELD)
		public @interface ForeignKey {
			String mappedBy();
		}
	}
	adds {
		package br.unb.cic.framework.persistence;
		
		/**
		 * Use to signal database exceptions.
		 * 
		 * @author rbonifacio.
		 */
		public class DBException extends Exception {
		
			private static final long serialVersionUID = 1L;
		
		}
	}
	adds {
		package br.unb.cic.framework.persistence;
		
		/**
		 * Exception that is thrown when an invalid Entity is identified by the
		 * persistence framework.
		 * 
		 * @author rbonifacio
		 */
		public class DBInvalidEntityException extends Exception {
		
			private static final long serialVersionUID = 1L;
		
			/**
			 * Constructor
			 * 
			 * @param e
			 *            the invalid entity
			 */
			public DBInvalidEntityException(Object e) {
				super(e.getClass().getCanonicalName() + "is not a valid entity according to the persistence framework.");
			}
		}
	}
	adds {
		package br.unb.cic.framework.persistence;

		/**
		 * An enumeration with the valid types that can be mapped into the database
		 * columns.
		 * 
		 * @author rbonifacio
		 */
		public enum DBTypes {
			INT, LONG, TEXT;
		}
	}
	adds {		
		package br.unb.cic.framework.persistence;
		
		import java.lang.reflect.Field;
		import java.lang.reflect.Method;
		import java.util.ArrayList;
		import java.util.List;
		
		import android.content.ContentValues;
		import android.content.Context;
		import android.database.Cursor;
		import android.database.sqlite.SQLiteDatabase;
		import android.util.Log;
		import br.unb.cic.framework.persistence.annotations.Column;
		import br.unb.cic.framework.persistence.annotations.Entity;
		import br.unb.cic.framework.persistence.annotations.ForeignKey;
		import br.unb.cic.reminders.model.db.DBHelper;
		import br.unb.cic.reminders.model.db.DefaultCategoryDAO;
		
		/**
		 * A generic DAO class.
		 * 
		 * @author rbonifacio
		 */
		public class GenericDAO<T> {
		
			protected Context context;
			protected SQLiteDatabase db;
			protected DBHelper dbHelper;
		
			private static final String DATABASE_NAME = "ReminderDB";
			private static final int DATABASE_VERSION = 7;
		
			/**
			 * Constructor of GenericDAO.
			 * 
			 * @param c
			 *            the application context.
			 */
			public GenericDAO(Context c) {
				context = c;
				dbHelper = new DBHelper(context, DATABASE_NAME, null, DATABASE_VERSION);
			}
		
			/**
			 * Save a specific entity into the database.
			 * 
			 * @param entity
			 *            that will be stored.
			 * 
			 * @return the Id of the entity in the database.
			 */
			protected Long persist(T entity) throws DBInvalidEntityException, DBException {
				try {
					db = dbHelper.getWritableDatabase();
		
					ContentValues values = new ContentValues();
		
					if (!entity.getClass().isAnnotationPresent(Entity.class)) {
						throw new DBInvalidEntityException(entity);
					}
		
					String tableName = entity.getClass().getAnnotation(Entity.class).table();
		
					boolean update = false;
					String updateWhereClause = null;
		
					for (Field f : entity.getClass().getDeclaredFields()) {
						if (f.isAnnotationPresent(Column.class)) {
							String column = f.getAnnotation(Column.class).column();
							boolean pk = f.getAnnotation(Column.class).primaryKey();
		
							String methodName = getMethod(f.getName());
							Class args[] = {};
							Method m = entity.getClass().getDeclaredMethod(methodName, args);
		
							Object value = m.invoke(entity, args);
		
							// in the cases where the field is a related object, mapped
							// by a FK, a specific
							// behavior is necessary, since we need to get the value of
							// the
							// primary key of the related object.
							if (f.isAnnotationPresent(ForeignKey.class)) {
								String fk = f.getAnnotation(ForeignKey.class).mappedBy();
								methodName = getMethod(fk);
		
								m = value.getClass().getDeclaredMethod(methodName, args);
		
								value = m.invoke(value, args);
							}
							if (value != null) {
								values.put(column, value.toString());
							} else {
								values.putNull(column);
							}
							if (pk && value != null) {
								update = true;
								updateWhereClause = column + " = " + value.toString();
							}
						}
					}
					Long id = null;
					db.beginTransaction();
					if (!update) {
						id = db.insert(tableName, null, values);
					} else {
						db.update(tableName, values, updateWhereClause, null);
					}
					db.setTransactionSuccessful();
					return id;
				} catch (Exception e) {
					e.printStackTrace();
					Log.e(DefaultCategoryDAO.class.getCanonicalName(), e.getLocalizedMessage());
					throw new DBException();
				} finally {
					if (db.inTransaction()) {
						db.endTransaction();
					}
					db.close();
					dbHelper.close();
				}
			}
		
			public T cursorToEntity(Cursor cursor, Class<T> clasz) throws DBInvalidEntityException, Exception {
				if (!clasz.isAnnotationPresent(Entity.class)) {
					throw new DBInvalidEntityException(clasz);
				}
		
				T entity = clasz.newInstance();
		
				for (Field f : declaredFields(clasz)) {
					Class args[] = { f.getType() };
		
					if (!f.isAnnotationPresent(ForeignKey.class)) {
						Method m = entity.getClass().getDeclaredMethod(setMethod(f.getName()), args);
		
						m.invoke(entity, fieldValueFromCursor(cursor, f));
					} else {
		
					}
				}
		
				return entity;
			}
		
			private Object fieldValueFromCursor(Cursor cursor, Field f) {
				String column = f.getAnnotation(Column.class).column();
				DBTypes type = f.getAnnotation(Column.class).type();
		
				switch (type) {
				case INT:
					return cursor.getInt(cursor.getColumnIndex(column));
				case LONG:
					return cursor.getLong(cursor.getColumnIndex(column));
				case TEXT:
					return cursor.getString(cursor.getColumnIndex(column));
				default:
					return null;
				}
			}
		
			private List<Field> declaredFields(Class<T> clasz) {
				List<Field> fields = new ArrayList<Field>();
				for (Field f : clasz.getDeclaredFields()) {
					if (f.isAnnotationPresent(Column.class)) {
						fields.add(f);
					}
				}
				return fields;
			}
		
			private String setMethod(String field) {
				return "set" + field.substring(0, 1).toUpperCase() + field.substring(1);
			}
		
			private String getMethod(String field) {
				return "get" + field.substring(0, 1).toUpperCase() + field.substring(1);
			}
		}
	}
	adds {
		package br.unb.cic.reminders.model;
		
		public enum Priority {
		
			LOW(0, "Sem Prioridade"), NORMAL(1, "Importante"), HIGH(2, "Urgente");
		
			int code;
			String description;
		
			private Priority(int code, String description) {
				this.code = code;
				this.description = description;
			}
		
			public int getCode() {
				return code;
			}
		
			static public Priority fromCode(int code) {
				for (Priority p : Priority.values()) {
					if (p.getCode() == code) {
						return p;
					}
				}
				throw new IllegalArgumentException();
			}
		
			@Override
			public String toString() {
				return description;
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.model;
		
		public class InvalidTextException extends InvalidFormatException {
		
			private static final long serialVersionUID = 7998188562654167391L;
		
			public InvalidTextException(Object o) {
				super("This text " + o);
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.model;

		/**
		 * Exception that might be used to report situations where an invalid format was
		 * detected. For instance, we throw an instance of this exception when we try to
		 * set a date as a string that does not match the expected date format.
		 * 
		 * @author rbonifacio
		 */
		public class InvalidFormatException extends RuntimeException {
		
			private static final long serialVersionUID = 2850584940310533216L;
		
			/**
			 * InvalidFormatException constructor.
			 * 
			 * @param o
			 *            An object that does not match an expected format.
			 */
			public InvalidFormatException(Object o) {
				super(o + " is in the wrong format");
			}
		}
	}
	adds {
		package br.unb.cic.reminders.model;
		
		public class InvalidDateException extends InvalidFormatException {
		
			private static final long serialVersionUID = 7194191177254259925L;
		
			public InvalidDateException(Object o) {
				super("This date " + o);
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.model.db;
		
		import android.content.Context;
		import android.database.sqlite.SQLiteDatabase;
		import android.database.sqlite.SQLiteDatabase.CursorFactory;
		import android.database.sqlite.SQLiteException;
		import android.database.sqlite.SQLiteOpenHelper;
		import android.util.Log;
		
		public class DBHelper extends SQLiteOpenHelper {
		
			public DBHelper(Context context, String name, CursorFactory factory, int version) {
				super(context, name, factory, version);
			}
		
			@Override
			public void onOpen(SQLiteDatabase db) {
				db.execSQL("PRAGMA foreign_keys=ON;");
				super.onOpen(db);
			}
		
			@Override
			public void onCreate(SQLiteDatabase db) {
				try {
					for (String sql : DBConstants.CREATE_TABLE_STATEMENTS) {
						Log.i(DBHelper.class.getCanonicalName(), sql);
						db.execSQL(sql);
					}
		
					for (String sql : DBConstants.PREDEFINED_CATEGORIES) {
						Log.i(DBHelper.class.getCanonicalName(), sql);
						db.execSQL(sql);
					}
				} catch (SQLiteException e) {
					Log.v(DBHelper.class.getName(), e.getMessage());
				}
			}
		
			@Override
			public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
				try {
					for (String sql : DBConstants.DROP_TABLE_STATEMENTS) {
						db.execSQL(sql);
					}
					onCreate(db);
				} catch (SQLiteException e) {
					Log.v(DBHelper.class.getName(), e.getMessage());
				}
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.model.db;
		
		import java.util.List;
		
		import br.unb.cic.framework.persistence.DBException;
		import br.unb.cic.reminders.model.Category;
		import br.unb.cic.reminders.model.Reminder;
		
		/**
		 * A Data Access Object for handling the persistence mechanism of reminders.
		 * 
		 * @author rbonifacio
		 */
		public interface ReminderDAO {
		
			/**
			 * Save a reminder in the reminders database.
			 * 
			 * @param reminder
			 *            - the reminder that will be stored.
			 * @return the reminder id.
			 */
			public Long saveReminder(Reminder r) throws DBException;
		
			/**
			 * List all reminders of the Reminders database.
			 * 
			 * @return list of registered reminders.
			 * @throws DBException
			 *             if anything goes wrong with the database query
			 */
			public List<Reminder> listReminders() throws DBException;
		
			/**
			 * List all reminders of the Reminders database, but using as criteria a
			 * given category
			 * 
			 * @param category
			 *            the category used as the query criteria
			 * @return list of registered reminders.
			 * @throws DBException
			 *             if anything goes wrong with the database query
			 */
			public List<Reminder> listRemindersByCategory(Category category) throws DBException;
		
			/**
			 * Update a given reminder from the database
			 * 
			 * @param reminder
			 *            the reminder that will be updated from the database. it
			 *            contains all fields with the new values and the id of the
			 *            reminder to be updated.
			 * @throws DBException
			 *             if anything goes wrong with the database query
			 */
			public void updateReminder(Reminder reminder) throws DBException;
		
			/**
			 * Delete a given reminder from the database
			 * 
			 * @param reminder
			 *            the reminder that will be dropped from the database
			 * @throws DBException
			 *             if anything goes wrong with the database query
			 */
			public void deleteReminder(Reminder reminder) throws DBException;
		
			/**
			 * Persist a given reminder from the database
			 * 
			 * @param reminder
			 *            the reminder that will be persisted in the database
			 * @throws DBException
			 *             if anything goes wrong with the database query
			 */
			public void persistReminder(Reminder reminder) throws DBException;
		}
	}
	adds {
		package br.unb.cic.reminders.model.db;
		
		import java.util.ArrayList;
		import java.util.List;
		
		import android.content.Context;
		import android.database.Cursor;
		import android.database.sqlite.SQLiteException;
		import android.util.Log;
		import br.unb.cic.framework.persistence.DBException;
		import br.unb.cic.framework.persistence.DBInvalidEntityException;
		import br.unb.cic.framework.persistence.GenericDAO;
		import br.unb.cic.reminders.model.Category;
		import br.unb.cic.reminders.model.Priority;
		import br.unb.cic.reminders.model.Reminder;
		
		/**
		 * A default implementation of the @see {@link ReminderDAO} interface.
		 * 
		 * @author positivo
		 *
		 */
		public class DefaultReminderDAO extends GenericDAO<Reminder> implements ReminderDAO {
		
			public DefaultReminderDAO(Context c) {
				super(c);
			}
		
			/**
			 * @see ReminderDAO#saveReminder(Reminder reminder)
			 */
			public Long saveReminder(Reminder r) throws DBException {
				try {
					return persist(r);
				} catch (DBInvalidEntityException e) {
					throw new DBException();
				}
			}
		
			/**
			 * @see ReminderDAO#saveReminder(Reminder)
			 */
			public List<Reminder> listReminders() throws DBException {
				try {
					db = dbHelper.getReadableDatabase();
					Cursor cursor = db.rawQuery(DBConstants.SELECT_REMINDERS, null);
		
					return remindersFromCursor(cursor);
				} catch (Exception e) {
					Log.e(DefaultCategoryDAO.class.getCanonicalName(), e.getLocalizedMessage());
					throw new DBException();
				} finally {
					db.close();
					dbHelper.close();
				}
			}
		
			/**
			 * @see ReminderDAO#deleteReminder(Reminder reminder)
			 */
			public List<Reminder> listRemindersByCategory(Category category) throws DBException {
				try {
					db = dbHelper.getReadableDatabase();
					Cursor cursor = db.rawQuery(DBConstants.SELECT_REMINDERS_BY_CATEGORY,
							new String[] { category.getId().toString() });
		
					return remindersFromCursor(cursor);
				} catch (Exception e) {
					Log.e(DefaultCategoryDAO.class.getCanonicalName(), e.getLocalizedMessage());
					throw new DBException();
				} finally {
					db.close();
					dbHelper.close();
				}
			}
		
			/**
			 * TODO: I guess that this note does not make sense any more.
			 * 
			 * @see ReminderDAO#updateReminder(Reminder reminder) As it was asked on
			 *      iceScrum, the update use the persist method after removing the given
			 *      reminder. If this was what was asked then it is done, otherwise the
			 *      persist method can be upgraded to support the update functionality
			 *      (if it isn't already implemented. I guess it isn't) later by
			 *      refactoring it.
			 */
			public void updateReminder(Reminder reminder) throws DBException {
				try {
					persist(reminder);
				} catch (DBInvalidEntityException e) {
					throw new DBException();
				} finally {
					db.close();
					dbHelper.close();
				}
			}
		
			/**
			 * @see ReminderDAO#deleteReminder(Reminder reminder)
			 */
			public void deleteReminder(Reminder reminder) throws DBException {
				try {
					db = dbHelper.getWritableDatabase();
					db.delete(DBConstants.REMINDER_TABLE, DBConstants.REMINDER_PK_COLUMN + "=" + reminder.getId(), null);
				} catch (SQLiteException e) {
					Log.e(DefaultCategoryDAO.class.getCanonicalName(), e.getLocalizedMessage());
					throw new DBException();
				} finally {
					db.close();
					dbHelper.close();
				}
			}
		
			public void persistReminder(Reminder reminder) throws DBException {
				try {
					persist(reminder);
				} catch (DBInvalidEntityException e) {
					throw new DBException();
				} finally {
					db.close();
					dbHelper.close();
				}
			}
		
			/*
			 * Transform a cursor into a Reminder
			 */
			private Reminder cursorToReminder(Cursor cursor) throws DBException {
				Long pk = cursor.getLong(cursor.getColumnIndex(DBConstants.REMINDER_PK_COLUMN));
				String text = cursor.getString(cursor.getColumnIndex(DBConstants.REMINDER_TEXT_COLUMN));
				String details = cursor.getString(cursor.getColumnIndex(DBConstants.REMINDER_DETAILS_COLUMN));
				String date = cursor.getString(cursor.getColumnIndex(DBConstants.REMINDER_DATE_COLUMN));
				String hour = cursor.getString(cursor.getColumnIndex(DBConstants.REMINDER_HOUR_COLUMN));
				int priority = cursor.getInt(cursor.getColumnIndex(DBConstants.REMINDER_PRIORITY_COLUMN));
				int done = cursor.getInt(cursor.getColumnIndex(DBConstants.REMINDER_DONE_COLUMN));
				Long categoryId = cursor.getLong(cursor.getColumnIndex(DBConstants.REMINDER_FK_CATEGORY_COLUMN));
		
				Category category = DBFactory.factory(context).createCategoryDAO().findCategoryById(categoryId);
		
				Reminder reminder = new Reminder();
		
				reminder.setText(text);
				reminder.setDetails(details);
				reminder.setId(pk);
				reminder.setDate(date);
				reminder.setHour(hour);
				reminder.setPriority(Priority.fromCode(priority));
				reminder.setDone(done);
				reminder.setCategory(category);
		
				return reminder;
			}
		
			/*
			 * Iterates over a cursor in order to build a list of reminders.
			 */
			private List<Reminder> remindersFromCursor(Cursor cursor) throws DBException {
				List<Reminder> reminders = new ArrayList<Reminder>();
		
				if (cursor.moveToFirst()) {
					do {
						Reminder reminder = cursorToReminder(cursor);
						reminders.add(reminder);
					} while (cursor.moveToNext());
				}
				cursor.close();
				return reminders;
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.view;
		
		import java.util.List;
		
		import android.content.Context;
		import android.view.LayoutInflater;
		import android.view.View;
		import android.view.ViewGroup;
		import android.widget.ArrayAdapter;
		import android.widget.LinearLayout;
		import android.widget.TextView;
		import br.unb.cic.reminders.model.Category;
		import br.unb.cic.reminders2.R;
		
		public class CategoryArrayAdapter extends ArrayAdapter<Category> {
		
			private Context context;
		
			/**
			 * This class is used in the parts of the view which is needed to list the
			 * categories, as an adapter to these components listing the Categories
			 * items.
			 * 
			 * @param context,
			 *            and the reminders objects(List<Category>).
			 * 
			 * @author positivo
			 * 
			 */
			public CategoryArrayAdapter(Context context, List<Category> objects) {
				super(context, R.layout.category_row, objects);
				this.context = context;
			}
		
			@Override
			public View getView(int position, View convertView, ViewGroup parent) {
				LinearLayout categoryRow;
		
				// Inflate the view
				if (convertView == null) {
					categoryRow = new LinearLayout(getContext());
					String inflater = Context.LAYOUT_INFLATER_SERVICE;
					LayoutInflater vi;
					vi = (LayoutInflater) getContext().getSystemService(inflater);
					vi.inflate(R.layout.category_row, categoryRow, true);
				} else {
					categoryRow = (LinearLayout) convertView;
				}
		
				TextView tvCategory = (TextView) categoryRow.findViewById(R.id.row_categoryName);
		
				tvCategory.setText(getItem(position).getName());
		
				return categoryRow;
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.view;
		
		import java.util.Calendar;
		
		import android.app.DatePickerDialog;
		import android.app.Dialog;
		import android.app.DialogFragment;
		import android.content.DialogInterface;
		import android.os.Bundle;
		import android.widget.ArrayAdapter;
		import android.widget.DatePicker;
		import android.widget.Spinner;
		
		class DatePickerDialogFragment extends DialogFragment implements DatePickerDialog.OnDateSetListener {
		
			private Calendar date;
			private Spinner spinnerDate;
		
			private int pYear;
			private int pDay;
			private int pMonth;
		
			public DatePickerDialogFragment(Calendar date, Spinner spinnerDate) {
				this.date = date;
				this.spinnerDate = spinnerDate;
			}
		
			@Override
			public Dialog onCreateDialog(Bundle savedInstanceState) {
				// Use the current date as the default date in the picker
				int year = date.get(Calendar.YEAR);
				int month = date.get(Calendar.MONTH);
				int day = date.get(Calendar.DAY_OF_MONTH);
		
				// Create a new instance of DatePickerDialog and return it
				return new DatePickerDialog(getActivity(), this, year, month, day);
			}
		
			@SuppressWarnings("unchecked")
			@Override
			public void onDismiss(DialogInterface dialog) {
				date.set(pYear, pMonth, pDay);
				String sDate = Integer.toString(pDay) + "-" + Integer.toString(pMonth + 1) + "-" + Integer.toString(pYear);
		
				ArrayAdapter<String> adapter = (ArrayAdapter<String>) spinnerDate.getAdapter();
		
				/* DO NOT DELETE THESE COMMENTS! (Alexandre) */
				/* Maybe we need it next Sprint. */
				// if(adapter.getCount() > 2) {
				// adapter.remove(adapter.getItem(2));
				// }
				adapter.add(sDate);
				spinnerDate.setSelection(2);
		
				super.onDismiss(dialog);
			}
		
			public void onDateSet(DatePicker view, int year, int month, int day) {
				pYear = year;
				pDay = day;
				pMonth = month;
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.view;
		
		import java.util.ArrayList;
		import java.util.List;
		
		import android.app.Fragment;
		import android.os.Bundle;
		import android.util.Log;
		import android.view.ContextMenu;
		import android.view.ContextMenu.ContextMenuInfo;
		import android.view.LayoutInflater;
		import android.view.MenuInflater;
		import android.view.View;
		import android.view.ViewGroup;
		import android.widget.AdapterView;
		import android.widget.AdapterView.OnItemClickListener;
		import android.widget.Button;
		import android.widget.ListView;
		import br.unb.cic.framework.persistence.DBException;
		import br.unb.cic.reminders.controller.AllRemindersFilter;
		import br.unb.cic.reminders.controller.CategoryFilter;
		import br.unb.cic.reminders.controller.Controller;
		import br.unb.cic.reminders.controller.PriorityFilter;
		import br.unb.cic.reminders.controller.ReminderFilter;
		import br.unb.cic.reminders.model.Category;
		import br.unb.cic.reminders.model.Priority;
		import br.unb.cic.reminders2.R;
		
		/**
		 * A list fragment that holds the list of categories.
		 * 
		 * @author rbonifacio
		 */
		public class FilterListFragment extends Fragment implements OnItemClickListener {
		
			private static final String CURRENT_FILTER_KEY = "current_filter";
		
			private static String TAG = "filter fragment list";
		
			private int currentFilterIndex;
		
			private List<FiltersListChangeListener> listeners;
		
			private FiltersListChangeListener filtersChangeListener;
		
			private int currentFilterId;
			// Used to list the filters.
			private ReminderFilterArrayAdapter adapter;
			private View view;
		
			private Button btAddCategory;
			private ListView lvFilters;
		
			@Override
			public void onActivityCreated(Bundle savedInstanceState) {
				super.onActivityCreated(savedInstanceState);
		
				// this way, we could retrieve the selected filter
				// after an orientation change.
				if (savedInstanceState != null) {
					currentFilterIndex = savedInstanceState.getInt(CURRENT_FILTER_KEY);
				}
		
				/*
				 * categoryList = new ArrayList<String>();
				 * 
				 * setListAdapter(new ArrayAdapter<String>(getActivity(),
				 * R.layout.list_content));
				 * 
				 * ListView thisListView = getListView();
				 * 
				 * categoriesArrayAdapter = (ArrayAdapter<String>)getListAdapter();
				 * 
				 * thisListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
				 * thisListView.setBackgroundColor(Color.WHITE);
				 */
		
				currentFilterId = 0;
		
				adapter = null;
			}
		
			/**
			 * Creates the view.
			 */
			@Override
			public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
				view = inflater.inflate(R.layout.categories_list_fragment, container, false);
				createUI();
				return view;
			}
		
			/**
			 * When resumed updates the filters list view.
			 */
			@Override
			public void onResume() {
				super.onResume();
				updateListView();
			}
		
			/**
			 * Creates the context menu where shows the Edit and Delete options.
			 */
			// @Override
			public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
				super.onCreateContextMenu(menu, v, menuInfo);
		
				menu.setHeaderTitle(R.string.context_menu_category_title);
		
				MenuInflater inflater = getActivity().getMenuInflater();
				inflater.inflate(R.menu.category_list_fragment_context_menu, menu);
			}
		
			/**
			 * Provides each action based in the chosen option(Edit or Delete).
			 **/
			/*
			 * @Override public boolean onContextItemSelected(MenuItem item) {
			 * 
			 * if(item.getGroupId() == R.id.context_menu_category) { //Used to verify if
			 * it is the right context_menu //Gets the item position and gets the
			 * category in that position: AdapterView.AdapterContextMenuInfo info =
			 * (AdapterView.AdapterContextMenuInfo)item.getMenuInfo(); Category category
			 * = (Category)lvCategory.getAdapter().getItem(info.position);
			 * 
			 * //Switch between the options in the context menu(Edit and Delete) switch
			 * (item.getItemId()) { case R.id.edit: //Passes the current reminder to be
			 * edited via Intent and Invokes edit method DialogFragment newFragment =
			 * new EditCategoryDialogFragment(category);
			 * newFragment.show(getFragmentManager(),
			 * ""+R.string.dialog_editcategory_title); updateListView(); return true;
			 * case R.id.delete: //Invokes delete method try {//Deletes from the bank;
			 * Controller
			 * .instance(getActivity().getApplicationContext()).deleteCategory(
			 * category); } catch (DBException e) { Log.e(TAG,e.getMessage()); }
			 * updateListView(); return true; default: return
			 * super.onContextItemSelected(item); }
			 * 
			 * } return super.onContextItemSelected(item); }
			 */
		
			public void addListener(FiltersListChangeListener filter) {
				if (listeners == null)
					listeners = new ArrayList<FiltersListChangeListener>();
				listeners.add(filter);
			}
		
			public void notifyListeners(ReminderFilter filter) {
				for (FiltersListChangeListener c : listeners) {
					c.onSelectedFilterChanged(filter);
				}
			}
		
			/**
			 * Creates the User Interface.
			 **/
			private void createUI() {
		
				// Button to add a Category:
				// btAddCategory = (Button) view.findViewById(R.id.btAddCategory);
				// btAddCategory.setOnClickListener(new OnClickListener() {
				//
				// public void onClick(View v) {// Creates one DialogFragment to add a
				// // category
				// DialogFragment newFragment = new AddCategoryDialogFragment();
				// newFragment.show(getFragmentManager(), ""
				// + R.string.dialog_addcategory_title);
				// }
				// });
		
				// List of filters
				lvFilters = (ListView) view.findViewById(R.id.listCategories);
				lvFilters.setOnItemClickListener(this);
				registerForContextMenu(lvFilters);
				updateListView();
			}
		
			/**
			 * Used to populate the list view with the current filters and other
			 * filters.
			 */
			private void updateListView() {
		
				List<ReminderFilter> filters = new ArrayList<ReminderFilter>();
		
				// Add the allReminders to the filter list
				AllRemindersFilter allRemindersFilter = new AllRemindersFilter(getActivity());
				filters.add(allRemindersFilter);
		
				// Add the priorities to the filter list
				PriorityFilter highPriorityFilter = new PriorityFilter(Priority.HIGH, getActivity());
				filters.add(highPriorityFilter);
				PriorityFilter normalPriorityFilter = new PriorityFilter(Priority.NORMAL, getActivity());
				filters.add(normalPriorityFilter);
				PriorityFilter lowPriorityFilter = new PriorityFilter(Priority.LOW, getActivity());
				filters.add(lowPriorityFilter);
		
				// Get all categories
				List<Category> categories = new ArrayList<Category>();
				try {
					categories = Controller.instance(getActivity().getApplicationContext()).listCategories();
					notifyListeners(null);
				} catch (DBException e) {
					Log.e(CURRENT_FILTER_KEY, "STORAGE_SERVICE error. Message: " + e.getMessage()); // TODO:
																									// Handle
																									// it
																									// properly.
					e.printStackTrace();
				} catch (Exception e) {
					Log.e(CURRENT_FILTER_KEY, "STORAGE_SERVICE error. Message: " + e.getMessage()); // TODO:
																									// Handle
																									// it
																									// properly.
					e.printStackTrace();
				}
		
				// Add the categories to the filter list
				ReminderFilter filter;
				for (Category c : categories) {
					filter = new CategoryFilter(c, getActivity());
					filters.add(filter);
				}
		
				adapter = new ReminderFilterArrayAdapter(getActivity().getApplicationContext(), filters);
		
				lvFilters.setAdapter(adapter);
			}
		
			public void onItemClick(AdapterView<T> adapterView, View view, int position, long id) {
				notifyListeners(adapter.getItem(position));
		
			}
		
			public void onNothingSelected(AdapterView<T> arg0) {
				// TODO Auto-generated method stub
		
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.view;
		
		import br.unb.cic.reminders.controller.ReminderFilter;
		
		/**
		 * Interface used to receive a category list changing notificaton.
		 * 
		 * @author rbonifacio
		 */
		public interface FiltersListChangeListener {
		
			public void onSelectedFilterChanged(ReminderFilter filter);
		
		}
	}
}
