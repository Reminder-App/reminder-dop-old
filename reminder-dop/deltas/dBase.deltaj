delta dBase {
	adds {
		package br.unb.cic.reminders;

		import android.app.Activity;
		import android.app.FragmentTransaction;
		import android.content.Intent;
		import android.os.Bundle;
		import android.view.Menu;
		import android.view.MenuInflater;
		import android.view.MenuItem;
		import br.unb.cic.reminders.view.AddReminderActivity;
		import br.unb.cic.reminders.view.FilterListFragment;
		import br.unb.cic.reminders.view.ReminderListFragment;
		import br.unb.cic.reminders2.R;
		
		public class ReminderMainActivity extends Activity {
		
			private static String TAG = "lembretes";
		
			/**
			 * Called when the activity is first created.
			 * 
			 * @param savedInstanceState
			 *            If the activity is being re-initialized after previously being
			 *            shut down then this Bundle contains the data it most recently
			 *            supplied in onSaveInstanceState(Bundle). <b>Note: Otherwise it
			 *            is null.</b>
			 */
			@Override
			protected void onCreate(Bundle savedInstanceState) {
				super.onCreate(savedInstanceState);
				setContentView(R.layout.reminders_main_activity);
				createUI();
			}
		
			/**
			 * Creates the User Interface. Creates the ListFragment.
			 */
			private void createUI() {
				FragmentTransaction ft = getFragmentManager().beginTransaction();
				ReminderListFragment listReminderFragment = new ReminderListFragment();
				FilterListFragment listCategoryFragment = new FilterListFragment();
				listCategoryFragment.addListener(listReminderFragment);
				ft.add(R.id.listReminders, listReminderFragment);
				ft.add(R.id.listCategories, listCategoryFragment);
				ft.commit();
			}
		
			/**
			 * Create Options Menu. Creates the buttons on the ActionBar.
			 */
			@Override
			public boolean onCreateOptionsMenu(Menu menu) {
				MenuInflater inflater = getMenuInflater();
				inflater.inflate(R.menu.action_bar_menu, menu);
				return true;
			}
		
			/**
			 * Switch between the buttons in the options menu.
			 */
			@Override
			public boolean onOptionsItemSelected(MenuItem item) {
				switch (item.getItemId()) {
				case R.id.menu_addReminder:
					// app icon in action bar clicked; go home
					Intent reminderIntent = new Intent(getApplicationContext(), AddReminderActivity.class);
					startActivity(reminderIntent);
					return true;
				case R.id.menu_searchReminder:
					return true;
				default:
					return super.onOptionsItemSelected(item);
				}
			}
		
		}
	}
	adds {
		package util;
		
		import java.text.ParseException;
		import java.text.SimpleDateFormat;
		import java.util.Date;
		import java.util.Locale;
		
		public class DateFormat {
			/*
			 * Static function that formats the database readable date into an object of
			 * type Date
			 */
			public static Date dateFormater(String dateUnformated) throws ParseException {
				SimpleDateFormat sdf = new SimpleDateFormat("dd-MM-yyyy HH:mm", Locale.getDefault());
				return sdf.parse(dateUnformated);
			}
			
		}
	}
	adds {
		package util;
		
		import android.text.Editable;
		import android.text.TextWatcher;
		import android.widget.EditText;
		
		/**
		 * Class used to mask the input of editTexts. For example for date:YYYY-MM-DD.
		 */
		public abstract class Mask {
		
			/**
			 * Unmasks a String;
			 */
			public static String unmask(String str) {
				return str.replaceAll("[:]", "").replaceAll("[.]", "").replaceAll("[-]", "").replaceAll("[/]", "")
						.replaceAll("[(]", "").replaceAll("[)]", "");
			}
		
			/**
			 * Inserts one mask to an EditText.
			 * 
			 * @param String
			 *            mask, EditText editText, the string is used to pass the format
			 *            of the mask through a string, for example "##-##-####" and the
			 *            EditText that will be watched and changed based in the mask.
			 */
			public static TextWatcher insert(final String mask, final EditText ediTxt) {
				return new TextWatcher() {
					boolean isUpdating;
					String old = "";
		
					public void onTextChanged(CharSequence s, int start, int before, int count) {
						String str = Mask.unmask(s.toString());
						String txt = "";
						if (isUpdating) {
							old = str;
							isUpdating = false;
							return;
						}
						int i = 0;
						boolean done = false;
						for (char m : mask.toCharArray()) {
							if (!done && m != '#' && str.length() > old.length()) {
								txt += m;
							} else if (!done && i < str.length()) {
								txt += str.charAt(i);
								i++;
							} else {
								done = true;
							}
						}
						isUpdating = true;
						ediTxt.setText(txt);
						ediTxt.setSelection(txt.length());
					}
		
					public void beforeTextChanged(CharSequence s, int start, int count, int after) {
					}
		
					public void afterTextChanged(Editable s) {
					}
				};
			}
		
		}
	}
	adds {
		package util;
		
		public class Patterns {
		
			// TODO: Fix TEXT_PATTERN to allow "." in the middle of text and not only in
			// the end of the sentence.
			public static final String TEXT_PATTERN = "[^.!?\\s][^.!?]*(?:[.!?](?![']?\\s|$)[^.!?]*)*[.!?]?[']?(?=\\s|$)";
		
			public static final String DATE_PATTERN = "(0[1-9]|[12][0-9]|3[01])[- /.](0[1-9]|1[012])[- /.](19|20)\\d\\d";
		
			public static final String HOUR_PATTERN = "([01]?[0-9]|2[0-3]):[0-5][0-9]";
		}
	}
	adds {
		package util;

		import android.view.View;
		import android.view.ViewGroup;
		import android.widget.ListAdapter;
		import android.widget.ListView;
		
		/**
		 * Created to give some general use functions.
		 * 
		 * @author rafaelsimao
		 */
		
		public class Utility {
		
			/**
			 * Rearrange the size of a ListView to its content size.
			 * 
			 * @param listView
			 */
			public static void setListViewHeightBasedOnChildren(ListView listView) {
				ListAdapter listAdapter = listView.getAdapter();
				if (listAdapter == null) {
					// pre-condition
					return;
				}
		
				int totalHeight = 0;
				for (int i = 0; i < listAdapter.getCount(); i++) {
					View listItem = listAdapter.getView(i, null, listView);
					listItem.measure(0, 0);
					totalHeight += listItem.getMeasuredHeight();
				}
		
				ViewGroup.LayoutParams params = listView.getLayoutParams();
				params.height = totalHeight + (listView.getDividerHeight()*(listAdapter.getCount() - 1));
				listView.setLayoutParams(params);
			}
		
		}
	}
	adds {
		package br.unb.cic.framework.persistence.annotations;

		import java.lang.annotation.ElementType;
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		import java.lang.annotation.Target;
		
		import br.unb.cic.framework.persistence.DBTypes;
		
		@Retention(RetentionPolicy.RUNTIME)
		@Target(ElementType.FIELD)
		public @interface Column {
			String column();
		
			boolean primaryKey() default false;
		
			DBTypes type();
		}
	}
	adds {
		package br.unb.cic.framework.persistence.annotations;
		
		import java.lang.annotation.ElementType;
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		import java.lang.annotation.Target;
		
		/**
		 * An interface to declare entity classes.
		 * 
		 * @author rbonifacio
		 */
		@Retention(RetentionPolicy.RUNTIME)
		@Target(ElementType.TYPE)
		public @interface Entity {
			String table();
		}
	}
	adds {
		package br.unb.cic.framework.persistence.annotations;
		
		import java.lang.annotation.ElementType;
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		import java.lang.annotation.Target;
		
		/**
		 * Used to map an attribute as a foreign key in the database.
		 * 
		 * @author rbonifacio
		 */
		@Retention(RetentionPolicy.RUNTIME)
		@Target(ElementType.FIELD)
		public @interface ForeignKey {
			String mappedBy();
		}
	}
	adds {
		package br.unb.cic.framework.persistence;
		
		/**
		 * Use to signal database exceptions.
		 * 
		 * @author rbonifacio.
		 */
		public class DBException extends Exception {
		
			private static final long serialVersionUID = 1L;
		
		}
	}
	adds {
		package br.unb.cic.framework.persistence;
		
		/**
		 * Exception that is thrown when an invalid Entity is identified by the
		 * persistence framework.
		 * 
		 * @author rbonifacio
		 */
		public class DBInvalidEntityException extends Exception {
		
			private static final long serialVersionUID = 1L;
		
			/**
			 * Constructor
			 * 
			 * @param e
			 *            the invalid entity
			 */
			public DBInvalidEntityException(Object e) {
				super(e.getClass().getCanonicalName() + "is not a valid entity according to the persistence framework.");
			}
		}
	}
	adds {
		package br.unb.cic.framework.persistence;

		/**
		 * An enumeration with the valid types that can be mapped into the database
		 * columns.
		 * 
		 * @author rbonifacio
		 */
		public enum DBTypes {
			INT, LONG, TEXT;
		}
	}
	adds {		
		package br.unb.cic.framework.persistence;
		
		import java.lang.reflect.Field;
		import java.lang.reflect.Method;
		import java.util.ArrayList;
		import java.util.List;
		
		import android.content.ContentValues;
		import android.content.Context;
		import android.database.Cursor;
		import android.database.sqlite.SQLiteDatabase;
		import android.util.Log;
		import br.unb.cic.framework.persistence.annotations.Column;
		import br.unb.cic.framework.persistence.annotations.Entity;
		import br.unb.cic.framework.persistence.annotations.ForeignKey;
		import br.unb.cic.reminders.model.db.DBHelper;
		import br.unb.cic.reminders.model.db.DefaultCategoryDAO;
		
		/**
		 * A generic DAO class.
		 * 
		 * @author rbonifacio
		 */
		public class GenericDAO<T> {
		
			protected Context context;
			protected SQLiteDatabase db;
			protected DBHelper dbHelper;
		
			private static final String DATABASE_NAME = "ReminderDB";
			private static final int DATABASE_VERSION = 7;
		
			/**
			 * Constructor of GenericDAO.
			 * 
			 * @param c
			 *            the application context.
			 */
			public GenericDAO(Context c) {
				context = c;
				dbHelper = new DBHelper(context, DATABASE_NAME, null, DATABASE_VERSION);
			}
		
			/**
			 * Save a specific entity into the database.
			 * 
			 * @param entity
			 *            that will be stored.
			 * 
			 * @return the Id of the entity in the database.
			 */
			protected Long persist(T entity) throws DBInvalidEntityException, DBException {
				try {
					db = dbHelper.getWritableDatabase();
		
					ContentValues values = new ContentValues();
		
					if (!entity.getClass().isAnnotationPresent(Entity.class)) {
						throw new DBInvalidEntityException(entity);
					}
		
					String tableName = entity.getClass().getAnnotation(Entity.class).table();
		
					boolean update = false;
					String updateWhereClause = null;
		
					for (Field f : entity.getClass().getDeclaredFields()) {
						if (f.isAnnotationPresent(Column.class)) {
							String column = f.getAnnotation(Column.class).column();
							boolean pk = f.getAnnotation(Column.class).primaryKey();
		
							String methodName = getMethod(f.getName());
							Class args[] = {};
							Method m = entity.getClass().getDeclaredMethod(methodName, args);
		
							Object value = m.invoke(entity, args);
		
							// in the cases where the field is a related object, mapped
							// by a FK, a specific
							// behavior is necessary, since we need to get the value of
							// the
							// primary key of the related object.
							if (f.isAnnotationPresent(ForeignKey.class)) {
								String fk = f.getAnnotation(ForeignKey.class).mappedBy();
								methodName = getMethod(fk);
		
								m = value.getClass().getDeclaredMethod(methodName, args);
		
								value = m.invoke(value, args);
							}
							if (value != null) {
								values.put(column, value.toString());
							} else {
								values.putNull(column);
							}
							if (pk && value != null) {
								update = true;
								updateWhereClause = column + " = " + value.toString();
							}
						}
					}
					Long id = null;
					db.beginTransaction();
					if (!update) {
						id = db.insert(tableName, null, values);
					} else {
						db.update(tableName, values, updateWhereClause, null);
					}
					db.setTransactionSuccessful();
					return id;
				} catch (Exception e) {
					e.printStackTrace();
					Log.e(DefaultCategoryDAO.class.getCanonicalName(), e.getLocalizedMessage());
					throw new DBException();
				} finally {
					if (db.inTransaction()) {
						db.endTransaction();
					}
					db.close();
					dbHelper.close();
				}
			}
		
			public T cursorToEntity(Cursor cursor, Class<T> clasz) throws DBInvalidEntityException, Exception {
				if (!clasz.isAnnotationPresent(Entity.class)) {
					throw new DBInvalidEntityException(clasz);
				}
		
				T entity = clasz.newInstance();
		
				for (Field f : declaredFields(clasz)) {
					Class args[] = { f.getType() };
		
					if (!f.isAnnotationPresent(ForeignKey.class)) {
						Method m = entity.getClass().getDeclaredMethod(setMethod(f.getName()), args);
		
						m.invoke(entity, fieldValueFromCursor(cursor, f));
					} else {
		
					}
				}
		
				return entity;
			}
		
			private Object fieldValueFromCursor(Cursor cursor, Field f) {
				String column = f.getAnnotation(Column.class).column();
				DBTypes type = f.getAnnotation(Column.class).type();
		
				switch (type) {
				case INT:
					return cursor.getInt(cursor.getColumnIndex(column));
				case LONG:
					return cursor.getLong(cursor.getColumnIndex(column));
				case TEXT:
					return cursor.getString(cursor.getColumnIndex(column));
				default:
					return null;
				}
			}
		
			private List<Field> declaredFields(Class<T> clasz) {
				List<Field> fields = new ArrayList<Field>();
				for (Field f : clasz.getDeclaredFields()) {
					if (f.isAnnotationPresent(Column.class)) {
						fields.add(f);
					}
				}
				return fields;
			}
		
			private String setMethod(String field) {
				return "set" + field.substring(0, 1).toUpperCase() + field.substring(1);
			}
		
			private String getMethod(String field) {
				return "get" + field.substring(0, 1).toUpperCase() + field.substring(1);
			}
		}
	}
	adds {
		package br.unb.cic.reminders.model;
		
		public enum Priority {
		
			LOW(0, "Sem Prioridade"), NORMAL(1, "Importante"), HIGH(2, "Urgente");
		
			int code;
			String description;
		
			private Priority(int code, String description) {
				this.code = code;
				this.description = description;
			}
		
			public int getCode() {
				return code;
			}
		
			static public Priority fromCode(int code) {
				for (Priority p : Priority.values()) {
					if (p.getCode() == code) {
						return p;
					}
				}
				throw new IllegalArgumentException();
			}
		
			@Override
			public String toString() {
				return description;
			}
		
		}
	}
}
