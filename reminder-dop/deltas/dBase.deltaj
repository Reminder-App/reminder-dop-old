delta dBase {
	adds {
		package br.unb.cic.reminders;

		import android.app.Activity;
		import android.app.FragmentTransaction;
		import android.content.Intent;
		import android.os.Bundle;
		import android.view.Menu;
		import android.view.MenuInflater;
		import android.view.MenuItem;
		import br.unb.cic.reminders.view.AddReminderActivity;
		import br.unb.cic.reminders.view.FilterListFragment;
		import br.unb.cic.reminders.view.ReminderListFragment;
		import br.unb.cic.reminders2.R;
		
		public class ReminderMainActivity extends Activity {
		
			private static String TAG = "lembretes";
		
			/**
			 * Called when the activity is first created.
			 * 
			 * @param savedInstanceState
			 *            If the activity is being re-initialized after previously being
			 *            shut down then this Bundle contains the data it most recently
			 *            supplied in onSaveInstanceState(Bundle). <b>Note: Otherwise it
			 *            is null.</b>
			 */
			@Override
			protected void onCreate(Bundle savedInstanceState) {
				super.onCreate(savedInstanceState);
				setContentView(R.layout.reminders_main_activity);
				createUI();
			}
		
			/**
			 * Creates the User Interface. Creates the ListFragment.
			 */
			private void createUI() {
				FragmentTransaction ft = getFragmentManager().beginTransaction();
				ReminderListFragment listReminderFragment = new ReminderListFragment();
				FilterListFragment listCategoryFragment = new FilterListFragment();
				listCategoryFragment.addListener(listReminderFragment);
				ft.add(R.id.listReminders, listReminderFragment);
				ft.add(R.id.listCategories, listCategoryFragment);
				ft.commit();
			}
		
			/**
			 * Create Options Menu. Creates the buttons on the ActionBar.
			 */
			@Override
			public boolean onCreateOptionsMenu(Menu menu) {
				MenuInflater inflater = getMenuInflater();
				inflater.inflate(R.menu.action_bar_menu, menu);
				return true;
			}
		
			/**
			 * Switch between the buttons in the options menu.
			 */
			@Override
			public boolean onOptionsItemSelected(MenuItem item) {
				switch (item.getItemId()) {
				case R.id.menu_addReminder:
					// app icon in action bar clicked; go home
					Intent reminderIntent = new Intent(getApplicationContext(), AddReminderActivity.class);
					startActivity(reminderIntent);
					return true;
				case R.id.menu_searchReminder:
					return true;
				default:
					return super.onOptionsItemSelected(item);
				}
			}
		
		}
	}
	adds {
		package util;
		
		import java.text.ParseException;
		import java.text.SimpleDateFormat;
		import java.util.Date;
		import java.util.Locale;
		
		public class DateFormat {
			/*
			 * Static function that formats the database readable date into an object of
			 * type Date
			 */
			public static Date dateFormater(String dateUnformated) throws ParseException {
				SimpleDateFormat sdf = new SimpleDateFormat("dd-MM-yyyy HH:mm", Locale.getDefault());
				return sdf.parse(dateUnformated);
			}
			
		}
	}
	adds {
		package util;
		
		import android.text.Editable;
		import android.text.TextWatcher;
		import android.widget.EditText;
		
		/**
		 * Class used to mask the input of editTexts. For example for date:YYYY-MM-DD.
		 */
		public abstract class Mask {
		
			/**
			 * Unmasks a String;
			 */
			public static String unmask(String str) {
				return str.replaceAll("[:]", "").replaceAll("[.]", "").replaceAll("[-]", "").replaceAll("[/]", "")
						.replaceAll("[(]", "").replaceAll("[)]", "");
			}
		
			/**
			 * Inserts one mask to an EditText.
			 * 
			 * @param String
			 *            mask, EditText editText, the string is used to pass the format
			 *            of the mask through a string, for example "##-##-####" and the
			 *            EditText that will be watched and changed based in the mask.
			 */
			public static TextWatcher insert(final String mask, final EditText ediTxt) {
				return new TextWatcher() {
					boolean isUpdating;
					String old = "";
		
					public void onTextChanged(CharSequence s, int start, int before, int count) {
						String str = Mask.unmask(s.toString());
						String txt = "";
						if (isUpdating) {
							old = str;
							isUpdating = false;
							return;
						}
						int i = 0;
						boolean done = false;
						for (char m : mask.toCharArray()) {
							if (!done && m != '#' && str.length() > old.length()) {
								txt += m;
							} else if (!done && i < str.length()) {
								txt += str.charAt(i);
								i++;
							} else {
								done = true;
							}
						}
						isUpdating = true;
						ediTxt.setText(txt);
						ediTxt.setSelection(txt.length());
					}
		
					public void beforeTextChanged(CharSequence s, int start, int count, int after) {
					}
		
					public void afterTextChanged(Editable s) {
					}
				};
			}
		
		}
	}
	adds {
		package util;
		
		public class Patterns {
		
			// TODO: Fix TEXT_PATTERN to allow "." in the middle of text and not only in
			// the end of the sentence.
			public static final String TEXT_PATTERN = "[^.!?\\s][^.!?]*(?:[.!?](?![']?\\s|$)[^.!?]*)*[.!?]?[']?(?=\\s|$)";
		
			public static final String DATE_PATTERN = "(0[1-9]|[12][0-9]|3[01])[- /.](0[1-9]|1[012])[- /.](19|20)\\d\\d";
		
			public static final String HOUR_PATTERN = "([01]?[0-9]|2[0-3]):[0-5][0-9]";
		}
	}
	adds {
		package util;

		import android.view.View;
		import android.view.ViewGroup;
		import android.widget.ListAdapter;
		import android.widget.ListView;
		
		/**
		 * Created to give some general use functions.
		 * 
		 * @author rafaelsimao
		 */
		
		public class Utility {
		
			/**
			 * Rearrange the size of a ListView to its content size.
			 * 
			 * @param listView
			 */
			public static void setListViewHeightBasedOnChildren(ListView listView) {
				ListAdapter listAdapter = listView.getAdapter();
				if (listAdapter == null) {
					// pre-condition
					return;
				}
		
				int totalHeight = 0;
				for (int i = 0; i < listAdapter.getCount(); i++) {
					View listItem = listAdapter.getView(i, null, listView);
					listItem.measure(0, 0);
					totalHeight += listItem.getMeasuredHeight();
				}
		
				ViewGroup.LayoutParams params = listView.getLayoutParams();
				params.height = totalHeight + (listView.getDividerHeight()*(listAdapter.getCount() - 1));
				listView.setLayoutParams(params);
			}
		
		}
	}
	adds {
		package br.unb.cic.framework.persistence.annotations;

		import java.lang.annotation.ElementType;
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		import java.lang.annotation.Target;
		
		import br.unb.cic.framework.persistence.DBTypes;
		
		@Retention(RetentionPolicy.RUNTIME)
		@Target(ElementType.FIELD)
		public @interface Column {
			String column();
		
			boolean primaryKey() default false;
		
			DBTypes type();
		}
	}
	adds {
		package br.unb.cic.framework.persistence.annotations;
		
		import java.lang.annotation.ElementType;
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		import java.lang.annotation.Target;
		
		/**
		 * An interface to declare entity classes.
		 * 
		 * @author rbonifacio
		 */
		@Retention(RetentionPolicy.RUNTIME)
		@Target(ElementType.TYPE)
		public @interface Entity {
			String table();
		}
	}
	adds {
		package br.unb.cic.framework.persistence.annotations;
		
		import java.lang.annotation.ElementType;
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		import java.lang.annotation.Target;
		
		/**
		 * Used to map an attribute as a foreign key in the database.
		 * 
		 * @author rbonifacio
		 */
		@Retention(RetentionPolicy.RUNTIME)
		@Target(ElementType.FIELD)
		public @interface ForeignKey {
			String mappedBy();
		}
	}
	adds {
		package br.unb.cic.framework.persistence;
		
		/**
		 * Use to signal database exceptions.
		 * 
		 * @author rbonifacio.
		 */
		public class DBException extends Exception {
		
			private static final long serialVersionUID = 1L;
		
		}
	}
	adds {
		package br.unb.cic.framework.persistence;
		
		/**
		 * Exception that is thrown when an invalid Entity is identified by the
		 * persistence framework.
		 * 
		 * @author rbonifacio
		 */
		public class DBInvalidEntityException extends Exception {
		
			private static final long serialVersionUID = 1L;
		
			/**
			 * Constructor
			 * 
			 * @param e
			 *            the invalid entity
			 */
			public DBInvalidEntityException(Object e) {
				super(e.getClass().getCanonicalName() + "is not a valid entity according to the persistence framework.");
			}
		}
	}
	adds {
		package br.unb.cic.framework.persistence;

		/**
		 * An enumeration with the valid types that can be mapped into the database
		 * columns.
		 * 
		 * @author rbonifacio
		 */
		public enum DBTypes {
			INT, LONG, TEXT;
		}
	}
	adds {		
		package br.unb.cic.framework.persistence;
		
		import java.lang.reflect.Field;
		import java.lang.reflect.Method;
		import java.util.ArrayList;
		import java.util.List;
		
		import android.content.ContentValues;
		import android.content.Context;
		import android.database.Cursor;
		import android.database.sqlite.SQLiteDatabase;
		import android.util.Log;
		import br.unb.cic.framework.persistence.annotations.Column;
		import br.unb.cic.framework.persistence.annotations.Entity;
		import br.unb.cic.framework.persistence.annotations.ForeignKey;
		import br.unb.cic.reminders.model.db.DBHelper;
		import br.unb.cic.reminders.model.db.DefaultCategoryDAO;
		
		/**
		 * A generic DAO class.
		 * 
		 * @author rbonifacio
		 */
		public class GenericDAO<T> {
		
			protected Context context;
			protected SQLiteDatabase db;
			protected DBHelper dbHelper;
		
			private static final String DATABASE_NAME = "ReminderDB";
			private static final int DATABASE_VERSION = 7;
		
			/**
			 * Constructor of GenericDAO.
			 * 
			 * @param c
			 *            the application context.
			 */
			public GenericDAO(Context c) {
				context = c;
				dbHelper = new DBHelper(context, DATABASE_NAME, null, DATABASE_VERSION);
			}
		
			/**
			 * Save a specific entity into the database.
			 * 
			 * @param entity
			 *            that will be stored.
			 * 
			 * @return the Id of the entity in the database.
			 */
			protected Long persist(T entity) throws DBInvalidEntityException, DBException {
				try {
					db = dbHelper.getWritableDatabase();
		
					ContentValues values = new ContentValues();
		
					if (!entity.getClass().isAnnotationPresent(Entity.class)) {
						throw new DBInvalidEntityException(entity);
					}
		
					String tableName = entity.getClass().getAnnotation(Entity.class).table();
		
					boolean update = false;
					String updateWhereClause = null;
		
					for (Field f : entity.getClass().getDeclaredFields()) {
						if (f.isAnnotationPresent(Column.class)) {
							String column = f.getAnnotation(Column.class).column();
							boolean pk = f.getAnnotation(Column.class).primaryKey();
		
							String methodName = getMethod(f.getName());
							Class args[] = {};
							Method m = entity.getClass().getDeclaredMethod(methodName, args);
		
							Object value = m.invoke(entity, args);
		
							// in the cases where the field is a related object, mapped
							// by a FK, a specific
							// behavior is necessary, since we need to get the value of
							// the
							// primary key of the related object.
							if (f.isAnnotationPresent(ForeignKey.class)) {
								String fk = f.getAnnotation(ForeignKey.class).mappedBy();
								methodName = getMethod(fk);
		
								m = value.getClass().getDeclaredMethod(methodName, args);
		
								value = m.invoke(value, args);
							}
							if (value != null) {
								values.put(column, value.toString());
							} else {
								values.putNull(column);
							}
							if (pk && value != null) {
								update = true;
								updateWhereClause = column + " = " + value.toString();
							}
						}
					}
					Long id = null;
					db.beginTransaction();
					if (!update) {
						id = db.insert(tableName, null, values);
					} else {
						db.update(tableName, values, updateWhereClause, null);
					}
					db.setTransactionSuccessful();
					return id;
				} catch (Exception e) {
					e.printStackTrace();
					Log.e(DefaultCategoryDAO.class.getCanonicalName(), e.getLocalizedMessage());
					throw new DBException();
				} finally {
					if (db.inTransaction()) {
						db.endTransaction();
					}
					db.close();
					dbHelper.close();
				}
			}
		
			public T cursorToEntity(Cursor cursor, Class<T> clasz) throws DBInvalidEntityException, Exception {
				if (!clasz.isAnnotationPresent(Entity.class)) {
					throw new DBInvalidEntityException(clasz);
				}
		
				T entity = clasz.newInstance();
		
				for (Field f : declaredFields(clasz)) {
					Class args[] = { f.getType() };
		
					if (!f.isAnnotationPresent(ForeignKey.class)) {
						Method m = entity.getClass().getDeclaredMethod(setMethod(f.getName()), args);
		
						m.invoke(entity, fieldValueFromCursor(cursor, f));
					} else {
		
					}
				}
		
				return entity;
			}
		
			private Object fieldValueFromCursor(Cursor cursor, Field f) {
				String column = f.getAnnotation(Column.class).column();
				DBTypes type = f.getAnnotation(Column.class).type();
		
				switch (type) {
				case INT:
					return cursor.getInt(cursor.getColumnIndex(column));
				case LONG:
					return cursor.getLong(cursor.getColumnIndex(column));
				case TEXT:
					return cursor.getString(cursor.getColumnIndex(column));
				default:
					return null;
				}
			}
		
			private List<Field> declaredFields(Class<T> clasz) {
				List<Field> fields = new ArrayList<Field>();
				for (Field f : clasz.getDeclaredFields()) {
					if (f.isAnnotationPresent(Column.class)) {
						fields.add(f);
					}
				}
				return fields;
			}
		
			private String setMethod(String field) {
				return "set" + field.substring(0, 1).toUpperCase() + field.substring(1);
			}
		
			private String getMethod(String field) {
				return "get" + field.substring(0, 1).toUpperCase() + field.substring(1);
			}
		}
	}
	adds {
		package br.unb.cic.reminders.model;
		
		public enum Priority {
		
			LOW(0, "Sem Prioridade"), NORMAL(1, "Importante"), HIGH(2, "Urgente");
		
			int code;
			String description;
		
			private Priority(int code, String description) {
				this.code = code;
				this.description = description;
			}
		
			public int getCode() {
				return code;
			}
		
			static public Priority fromCode(int code) {
				for (Priority p : Priority.values()) {
					if (p.getCode() == code) {
						return p;
					}
				}
				throw new IllegalArgumentException();
			}
		
			@Override
			public String toString() {
				return description;
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.model;
		
		public class InvalidTextException extends InvalidFormatException {
		
			private static final long serialVersionUID = 7998188562654167391L;
		
			public InvalidTextException(Object o) {
				super("This text " + o);
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.model;

		/**
		 * Exception that might be used to report situations where an invalid format was
		 * detected. For instance, we throw an instance of this exception when we try to
		 * set a date as a string that does not match the expected date format.
		 * 
		 * @author rbonifacio
		 */
		public class InvalidFormatException extends RuntimeException {
		
			private static final long serialVersionUID = 2850584940310533216L;
		
			/**
			 * InvalidFormatException constructor.
			 * 
			 * @param o
			 *            An object that does not match an expected format.
			 */
			public InvalidFormatException(Object o) {
				super(o + " is in the wrong format");
			}
		}
	}
	adds {
		package br.unb.cic.reminders.model;
		
		public class InvalidDateException extends InvalidFormatException {
		
			private static final long serialVersionUID = 7194191177254259925L;
		
			public InvalidDateException(Object o) {
				super("This date " + o);
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.model.db;
		
		import android.content.Context;
		import android.database.sqlite.SQLiteDatabase;
		import android.database.sqlite.SQLiteDatabase.CursorFactory;
		import android.database.sqlite.SQLiteException;
		import android.database.sqlite.SQLiteOpenHelper;
		import android.util.Log;
		
		public class DBHelper extends SQLiteOpenHelper {
		
			public DBHelper(Context context, String name, CursorFactory factory, int version) {
				super(context, name, factory, version);
			}
		
			@Override
			public void onOpen(SQLiteDatabase db) {
				db.execSQL("PRAGMA foreign_keys=ON;");
				super.onOpen(db);
			}
		
			@Override
			public void onCreate(SQLiteDatabase db) {
				try {
					for (String sql : DBConstants.CREATE_TABLE_STATEMENTS) {
						Log.i(DBHelper.class.getCanonicalName(), sql);
						db.execSQL(sql);
					}
		
					for (String sql : DBConstants.PREDEFINED_CATEGORIES) {
						Log.i(DBHelper.class.getCanonicalName(), sql);
						db.execSQL(sql);
					}
				} catch (SQLiteException e) {
					Log.v(DBHelper.class.getName(), e.getMessage());
				}
			}
		
			@Override
			public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
				try {
					for (String sql : DBConstants.DROP_TABLE_STATEMENTS) {
						db.execSQL(sql);
					}
					onCreate(db);
				} catch (SQLiteException e) {
					Log.v(DBHelper.class.getName(), e.getMessage());
				}
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.model.db;
		
		import java.util.List;
		
		import br.unb.cic.framework.persistence.DBException;
		import br.unb.cic.reminders.model.Category;
		import br.unb.cic.reminders.model.Reminder;
		
		/**
		 * A Data Access Object for handling the persistence mechanism of reminders.
		 * 
		 * @author rbonifacio
		 */
		public interface ReminderDAO {
		
			/**
			 * Save a reminder in the reminders database.
			 * 
			 * @param reminder
			 *            - the reminder that will be stored.
			 * @return the reminder id.
			 */
			public Long saveReminder(Reminder r) throws DBException;
		
			/**
			 * List all reminders of the Reminders database.
			 * 
			 * @return list of registered reminders.
			 * @throws DBException
			 *             if anything goes wrong with the database query
			 */
			public List<Reminder> listReminders() throws DBException;
		
			/**
			 * List all reminders of the Reminders database, but using as criteria a
			 * given category
			 * 
			 * @param category
			 *            the category used as the query criteria
			 * @return list of registered reminders.
			 * @throws DBException
			 *             if anything goes wrong with the database query
			 */
			public List<Reminder> listRemindersByCategory(Category category) throws DBException;
		
			/**
			 * Update a given reminder from the database
			 * 
			 * @param reminder
			 *            the reminder that will be updated from the database. it
			 *            contains all fields with the new values and the id of the
			 *            reminder to be updated.
			 * @throws DBException
			 *             if anything goes wrong with the database query
			 */
			public void updateReminder(Reminder reminder) throws DBException;
		
			/**
			 * Delete a given reminder from the database
			 * 
			 * @param reminder
			 *            the reminder that will be dropped from the database
			 * @throws DBException
			 *             if anything goes wrong with the database query
			 */
			public void deleteReminder(Reminder reminder) throws DBException;
		
			/**
			 * Persist a given reminder from the database
			 * 
			 * @param reminder
			 *            the reminder that will be persisted in the database
			 * @throws DBException
			 *             if anything goes wrong with the database query
			 */
			public void persistReminder(Reminder reminder) throws DBException;
		}
	}
	adds {
		package br.unb.cic.reminders.model.db;
		
		import java.util.ArrayList;
		import java.util.List;
		
		import android.content.Context;
		import android.database.Cursor;
		import android.database.sqlite.SQLiteException;
		import android.util.Log;
		import br.unb.cic.framework.persistence.DBException;
		import br.unb.cic.framework.persistence.DBInvalidEntityException;
		import br.unb.cic.framework.persistence.GenericDAO;
		import br.unb.cic.reminders.model.Category;
		import br.unb.cic.reminders.model.Priority;
		import br.unb.cic.reminders.model.Reminder;
		
		/**
		 * A default implementation of the @see {@link ReminderDAO} interface.
		 * 
		 * @author positivo
		 *
		 */
		public class DefaultReminderDAO extends GenericDAO<Reminder> implements ReminderDAO {
		
			public DefaultReminderDAO(Context c) {
				super(c);
			}
		
			/**
			 * @see ReminderDAO#saveReminder(Reminder reminder)
			 */
			public Long saveReminder(Reminder r) throws DBException {
				try {
					return persist(r);
				} catch (DBInvalidEntityException e) {
					throw new DBException();
				}
			}
		
			/**
			 * @see ReminderDAO#saveReminder(Reminder)
			 */
			public List<Reminder> listReminders() throws DBException {
				try {
					db = dbHelper.getReadableDatabase();
					Cursor cursor = db.rawQuery(DBConstants.SELECT_REMINDERS, null);
		
					return remindersFromCursor(cursor);
				} catch (Exception e) {
					Log.e(DefaultCategoryDAO.class.getCanonicalName(), e.getLocalizedMessage());
					throw new DBException();
				} finally {
					db.close();
					dbHelper.close();
				}
			}
		
			/**
			 * @see ReminderDAO#deleteReminder(Reminder reminder)
			 */
			public List<Reminder> listRemindersByCategory(Category category) throws DBException {
				try {
					db = dbHelper.getReadableDatabase();
					Cursor cursor = db.rawQuery(DBConstants.SELECT_REMINDERS_BY_CATEGORY,
							new String[] { category.getId().toString() });
		
					return remindersFromCursor(cursor);
				} catch (Exception e) {
					Log.e(DefaultCategoryDAO.class.getCanonicalName(), e.getLocalizedMessage());
					throw new DBException();
				} finally {
					db.close();
					dbHelper.close();
				}
			}
		
			/**
			 * TODO: I guess that this note does not make sense any more.
			 * 
			 * @see ReminderDAO#updateReminder(Reminder reminder) As it was asked on
			 *      iceScrum, the update use the persist method after removing the given
			 *      reminder. If this was what was asked then it is done, otherwise the
			 *      persist method can be upgraded to support the update functionality
			 *      (if it isn't already implemented. I guess it isn't) later by
			 *      refactoring it.
			 */
			public void updateReminder(Reminder reminder) throws DBException {
				try {
					persist(reminder);
				} catch (DBInvalidEntityException e) {
					throw new DBException();
				} finally {
					db.close();
					dbHelper.close();
				}
			}
		
			/**
			 * @see ReminderDAO#deleteReminder(Reminder reminder)
			 */
			public void deleteReminder(Reminder reminder) throws DBException {
				try {
					db = dbHelper.getWritableDatabase();
					db.delete(DBConstants.REMINDER_TABLE, DBConstants.REMINDER_PK_COLUMN + "=" + reminder.getId(), null);
				} catch (SQLiteException e) {
					Log.e(DefaultCategoryDAO.class.getCanonicalName(), e.getLocalizedMessage());
					throw new DBException();
				} finally {
					db.close();
					dbHelper.close();
				}
			}
		
			public void persistReminder(Reminder reminder) throws DBException {
				try {
					persist(reminder);
				} catch (DBInvalidEntityException e) {
					throw new DBException();
				} finally {
					db.close();
					dbHelper.close();
				}
			}
		
			/*
			 * Transform a cursor into a Reminder
			 */
			private Reminder cursorToReminder(Cursor cursor) throws DBException {
				Long pk = cursor.getLong(cursor.getColumnIndex(DBConstants.REMINDER_PK_COLUMN));
				String text = cursor.getString(cursor.getColumnIndex(DBConstants.REMINDER_TEXT_COLUMN));
				String details = cursor.getString(cursor.getColumnIndex(DBConstants.REMINDER_DETAILS_COLUMN));
				String date = cursor.getString(cursor.getColumnIndex(DBConstants.REMINDER_DATE_COLUMN));
				String hour = cursor.getString(cursor.getColumnIndex(DBConstants.REMINDER_HOUR_COLUMN));
				int priority = cursor.getInt(cursor.getColumnIndex(DBConstants.REMINDER_PRIORITY_COLUMN));
				int done = cursor.getInt(cursor.getColumnIndex(DBConstants.REMINDER_DONE_COLUMN));
				Long categoryId = cursor.getLong(cursor.getColumnIndex(DBConstants.REMINDER_FK_CATEGORY_COLUMN));
		
				Category category = DBFactory.factory(context).createCategoryDAO().findCategoryById(categoryId);
		
				Reminder reminder = new Reminder();
		
				reminder.setText(text);
				reminder.setDetails(details);
				reminder.setId(pk);
				reminder.setDate(date);
				reminder.setHour(hour);
				reminder.setPriority(Priority.fromCode(priority));
				reminder.setDone(done);
				reminder.setCategory(category);
		
				return reminder;
			}
		
			/*
			 * Iterates over a cursor in order to build a list of reminders.
			 */
			private List<Reminder> remindersFromCursor(Cursor cursor) throws DBException {
				List<Reminder> reminders = new ArrayList<Reminder>();
		
				if (cursor.moveToFirst()) {
					do {
						Reminder reminder = cursorToReminder(cursor);
						reminders.add(reminder);
					} while (cursor.moveToNext());
				}
				cursor.close();
				return reminders;
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.view;
		
		import java.util.List;
		
		import android.content.Context;
		import android.view.LayoutInflater;
		import android.view.View;
		import android.view.ViewGroup;
		import android.widget.ArrayAdapter;
		import android.widget.LinearLayout;
		import android.widget.TextView;
		import br.unb.cic.reminders.model.Category;
		import br.unb.cic.reminders2.R;
		
		public class CategoryArrayAdapter extends ArrayAdapter<Category> {
		
			private Context context;
		
			/**
			 * This class is used in the parts of the view which is needed to list the
			 * categories, as an adapter to these components listing the Categories
			 * items.
			 * 
			 * @param context,
			 *            and the reminders objects(List<Category>).
			 * 
			 * @author positivo
			 * 
			 */
			public CategoryArrayAdapter(Context context, List<Category> objects) {
				super(context, R.layout.category_row, objects);
				this.context = context;
			}
		
			@Override
			public View getView(int position, View convertView, ViewGroup parent) {
				LinearLayout categoryRow;
		
				// Inflate the view
				if (convertView == null) {
					categoryRow = new LinearLayout(getContext());
					String inflater = Context.LAYOUT_INFLATER_SERVICE;
					LayoutInflater vi;
					vi = (LayoutInflater) getContext().getSystemService(inflater);
					vi.inflate(R.layout.category_row, categoryRow, true);
				} else {
					categoryRow = (LinearLayout) convertView;
				}
		
				TextView tvCategory = (TextView) categoryRow.findViewById(R.id.row_categoryName);
		
				tvCategory.setText(getItem(position).getName());
		
				return categoryRow;
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.view;
		
		import java.util.Calendar;
		
		import android.app.DatePickerDialog;
		import android.app.Dialog;
		import android.app.DialogFragment;
		import android.content.DialogInterface;
		import android.os.Bundle;
		import android.widget.ArrayAdapter;
		import android.widget.DatePicker;
		import android.widget.Spinner;
		
		class DatePickerDialogFragment extends DialogFragment implements DatePickerDialog.OnDateSetListener {
		
			private Calendar date;
			private Spinner spinnerDate;
		
			private int pYear;
			private int pDay;
			private int pMonth;
		
			public DatePickerDialogFragment(Calendar date, Spinner spinnerDate) {
				this.date = date;
				this.spinnerDate = spinnerDate;
			}
		
			@Override
			public Dialog onCreateDialog(Bundle savedInstanceState) {
				// Use the current date as the default date in the picker
				int year = date.get(Calendar.YEAR);
				int month = date.get(Calendar.MONTH);
				int day = date.get(Calendar.DAY_OF_MONTH);
		
				// Create a new instance of DatePickerDialog and return it
				return new DatePickerDialog(getActivity(), this, year, month, day);
			}
		
			@SuppressWarnings("unchecked")
			@Override
			public void onDismiss(DialogInterface dialog) {
				date.set(pYear, pMonth, pDay);
				String sDate = Integer.toString(pDay) + "-" + Integer.toString(pMonth + 1) + "-" + Integer.toString(pYear);
		
				ArrayAdapter<String> adapter = (ArrayAdapter<String>) spinnerDate.getAdapter();
		
				/* DO NOT DELETE THESE COMMENTS! (Alexandre) */
				/* Maybe we need it next Sprint. */
				// if(adapter.getCount() > 2) {
				// adapter.remove(adapter.getItem(2));
				// }
				adapter.add(sDate);
				spinnerDate.setSelection(2);
		
				super.onDismiss(dialog);
			}
		
			public void onDateSet(DatePicker view, int year, int month, int day) {
				pYear = year;
				pDay = day;
				pMonth = month;
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.view;
		
		import java.util.ArrayList;
		import java.util.List;
		
		import android.app.Fragment;
		import android.os.Bundle;
		import android.util.Log;
		import android.view.ContextMenu;
		import android.view.ContextMenu.ContextMenuInfo;
		import android.view.LayoutInflater;
		import android.view.MenuInflater;
		import android.view.View;
		import android.view.ViewGroup;
		import android.widget.AdapterView;
		import android.widget.AdapterView.OnItemClickListener;
		import android.widget.Button;
		import android.widget.ListView;
		import br.unb.cic.framework.persistence.DBException;
		import br.unb.cic.reminders.controller.AllRemindersFilter;
		import br.unb.cic.reminders.controller.CategoryFilter;
		import br.unb.cic.reminders.controller.Controller;
		import br.unb.cic.reminders.controller.PriorityFilter;
		import br.unb.cic.reminders.controller.ReminderFilter;
		import br.unb.cic.reminders.model.Category;
		import br.unb.cic.reminders.model.Priority;
		import br.unb.cic.reminders2.R;
		
		/**
		 * A list fragment that holds the list of categories.
		 * 
		 * @author rbonifacio
		 */
		public class FilterListFragment extends Fragment implements OnItemClickListener {
		
			private static final String CURRENT_FILTER_KEY = "current_filter";
		
			private static String TAG = "filter fragment list";
		
			private int currentFilterIndex;
		
			private List<FiltersListChangeListener> listeners;
		
			private FiltersListChangeListener filtersChangeListener;
		
			private int currentFilterId;
			// Used to list the filters.
			private ReminderFilterArrayAdapter adapter;
			private View view;
		
			private Button btAddCategory;
			private ListView lvFilters;
		
			@Override
			public void onActivityCreated(Bundle savedInstanceState) {
				super.onActivityCreated(savedInstanceState);
		
				// this way, we could retrieve the selected filter
				// after an orientation change.
				if (savedInstanceState != null) {
					currentFilterIndex = savedInstanceState.getInt(CURRENT_FILTER_KEY);
				}
		
				/*
				 * categoryList = new ArrayList<String>();
				 * 
				 * setListAdapter(new ArrayAdapter<String>(getActivity(),
				 * R.layout.list_content));
				 * 
				 * ListView thisListView = getListView();
				 * 
				 * categoriesArrayAdapter = (ArrayAdapter<String>)getListAdapter();
				 * 
				 * thisListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
				 * thisListView.setBackgroundColor(Color.WHITE);
				 */
		
				currentFilterId = 0;
		
				adapter = null;
			}
		
			/**
			 * Creates the view.
			 */
			@Override
			public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
				view = inflater.inflate(R.layout.categories_list_fragment, container, false);
				createUI();
				return view;
			}
		
			/**
			 * When resumed updates the filters list view.
			 */
			@Override
			public void onResume() {
				super.onResume();
				updateListView();
			}
		
			/**
			 * Creates the context menu where shows the Edit and Delete options.
			 */
			// @Override
			public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
				super.onCreateContextMenu(menu, v, menuInfo);
		
				menu.setHeaderTitle(R.string.context_menu_category_title);
		
				MenuInflater inflater = getActivity().getMenuInflater();
				inflater.inflate(R.menu.category_list_fragment_context_menu, menu);
			}
		
			/**
			 * Provides each action based in the chosen option(Edit or Delete).
			 **/
			/*
			 * @Override public boolean onContextItemSelected(MenuItem item) {
			 * 
			 * if(item.getGroupId() == R.id.context_menu_category) { //Used to verify if
			 * it is the right context_menu //Gets the item position and gets the
			 * category in that position: AdapterView.AdapterContextMenuInfo info =
			 * (AdapterView.AdapterContextMenuInfo)item.getMenuInfo(); Category category
			 * = (Category)lvCategory.getAdapter().getItem(info.position);
			 * 
			 * //Switch between the options in the context menu(Edit and Delete) switch
			 * (item.getItemId()) { case R.id.edit: //Passes the current reminder to be
			 * edited via Intent and Invokes edit method DialogFragment newFragment =
			 * new EditCategoryDialogFragment(category);
			 * newFragment.show(getFragmentManager(),
			 * ""+R.string.dialog_editcategory_title); updateListView(); return true;
			 * case R.id.delete: //Invokes delete method try {//Deletes from the bank;
			 * Controller
			 * .instance(getActivity().getApplicationContext()).deleteCategory(
			 * category); } catch (DBException e) { Log.e(TAG,e.getMessage()); }
			 * updateListView(); return true; default: return
			 * super.onContextItemSelected(item); }
			 * 
			 * } return super.onContextItemSelected(item); }
			 */
		
			public void addListener(FiltersListChangeListener filter) {
				if (listeners == null)
					listeners = new ArrayList<FiltersListChangeListener>();
				listeners.add(filter);
			}
		
			public void notifyListeners(ReminderFilter filter) {
				for (FiltersListChangeListener c : listeners) {
					c.onSelectedFilterChanged(filter);
				}
			}
		
			/**
			 * Creates the User Interface.
			 **/
			private void createUI() {
		
				// Button to add a Category:
				// btAddCategory = (Button) view.findViewById(R.id.btAddCategory);
				// btAddCategory.setOnClickListener(new OnClickListener() {
				//
				// public void onClick(View v) {// Creates one DialogFragment to add a
				// // category
				// DialogFragment newFragment = new AddCategoryDialogFragment();
				// newFragment.show(getFragmentManager(), ""
				// + R.string.dialog_addcategory_title);
				// }
				// });
		
				// List of filters
				lvFilters = (ListView) view.findViewById(R.id.listCategories);
				lvFilters.setOnItemClickListener(this);
				registerForContextMenu(lvFilters);
				updateListView();
			}
		
			/**
			 * Used to populate the list view with the current filters and other
			 * filters.
			 */
			private void updateListView() {
		
				List<ReminderFilter> filters = new ArrayList<ReminderFilter>();
		
				// Add the allReminders to the filter list
				AllRemindersFilter allRemindersFilter = new AllRemindersFilter(getActivity());
				filters.add(allRemindersFilter);
		
				// Add the priorities to the filter list
				PriorityFilter highPriorityFilter = new PriorityFilter(Priority.HIGH, getActivity());
				filters.add(highPriorityFilter);
				PriorityFilter normalPriorityFilter = new PriorityFilter(Priority.NORMAL, getActivity());
				filters.add(normalPriorityFilter);
				PriorityFilter lowPriorityFilter = new PriorityFilter(Priority.LOW, getActivity());
				filters.add(lowPriorityFilter);
		
				// Get all categories
				List<Category> categories = new ArrayList<Category>();
				try {
					categories = Controller.instance(getActivity().getApplicationContext()).listCategories();
					notifyListeners(null);
				} catch (DBException e) {
					Log.e(CURRENT_FILTER_KEY, "STORAGE_SERVICE error. Message: " + e.getMessage()); // TODO:
																									// Handle
																									// it
																									// properly.
					e.printStackTrace();
				} catch (Exception e) {
					Log.e(CURRENT_FILTER_KEY, "STORAGE_SERVICE error. Message: " + e.getMessage()); // TODO:
																									// Handle
																									// it
																									// properly.
					e.printStackTrace();
				}
		
				// Add the categories to the filter list
				ReminderFilter filter;
				for (Category c : categories) {
					filter = new CategoryFilter(c, getActivity());
					filters.add(filter);
				}
		
				adapter = new ReminderFilterArrayAdapter(getActivity().getApplicationContext(), filters);
		
				lvFilters.setAdapter(adapter);
			}
		
			public void onItemClick(AdapterView<? extends Object> adapterView, View view, int position, long id) {
				notifyListeners(adapter.getItem(position));
		
			}
		
			public void onNothingSelected(AdapterView<? extends Object> arg0) {
				// TODO Auto-generated method stub
		
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.view;
		
		import br.unb.cic.reminders.controller.ReminderFilter;
		
		/**
		 * Interface used to receive a category list changing notificaton.
		 * 
		 * @author rbonifacio
		 */
		public interface FiltersListChangeListener {
		
			public void onSelectedFilterChanged(ReminderFilter filter);
		
		}
	}
	adds {
		package br.unb.cic.reminders.view;
		
		import br.unb.cic.reminders.model.InvalidFormatException;
		
		public class InvalidHourException extends InvalidFormatException {
		
			private static final long serialVersionUID = 8341230773647025695L;
		
			public InvalidHourException(Object o) {
				super("This hour " + o);
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.view;
		
		import java.util.Arrays;
		import java.util.List;
		
		import util.Mask;
		import android.app.Activity;
		import android.content.Intent;
		import android.os.Bundle;
		import android.util.Log;
		import android.view.View;
		import android.widget.AdapterView;
		import android.widget.AdapterView.OnItemSelectedListener;
		import android.widget.ArrayAdapter;
		import android.widget.Button;
		import android.widget.EditText;
		import android.widget.Spinner;
		import android.widget.Toast;
		import br.unb.cic.reminders.controller.Controller;
		import br.unb.cic.reminders.model.Category;
		import br.unb.cic.reminders.model.InvalidDateException;
		import br.unb.cic.reminders.model.InvalidFormatException;
		import br.unb.cic.reminders.model.InvalidTextException;
		import br.unb.cic.reminders.model.Priority;
		import br.unb.cic.reminders.model.Reminder;
		import br.unb.cic.reminders2.R;
		
		/**
		 * Activity used to add reminders (local or from external applications).
		 * 
		 * If an external app wants to add a reminder, it must pass all the
		 * corresponding reminders' attributes to the intent which starts this activity.
		 * They are: "text", "category", "date" and "hour".
		 */
		
		public class ReminderAddActivity extends Activity {
		
			private EditText edtReminder, edtDetails, edtDate, edtHour; // ,
																		// edtPriority,
																		// edtCategory;
		
			private Category selectedCategory;
		
			private Priority selectedPriority;
		
			private Spinner spinnerPriority, spinnerCategory;
		
			private Button btnSave, btnCancel;
		
			private boolean editingReminder;
			private Long previewReminderId;
		
			@Override
			public void onCreate(Bundle savedInstanceState) {
				super.onCreate(savedInstanceState);
				setContentView(R.layout.reminder_add);
		
				/*
				 * Checks whether reminder's data exists in the intent, that is, verify
				 * if this activity was started by an external app.
				 */
				Reminder existingReminder = getReminderFromIntent();
		
				if (existingReminder == null) {
					// Used to get the informations of the Reminder being edited:
					editingReminder = true;
					Reminder editReminder = getExistingReminder();
					initialize(editReminder);
				} else {
					/*
					 * Initialize the view, optionally filling the fields with content
					 * sent by another app. This is the ONLY purpose of the object
					 * "existingReminder".
					 */
					editingReminder = false;
					initialize(existingReminder);
				}
		
				configureActionListener();
		
			}
		
			private void configureActionListener() {
				addListenerToBtnSave();
				addListenerToBtnCancel();
				addListenerToSpinnerPriority();
				addListenerToSpinnerCategory();
			}
		
			private void addListenerToSpinnerCategory() {
				spinnerCategory.setOnItemSelectedListener(new OnItemSelectedListener() {
					public void onItemSelected(AdapterView<? extends Object> parent, View view, int pos, long id) {
						// get the category from the spinner
						selectedCategory = (Category) parent.getItemAtPosition(pos);
					}
		
					public void onNothingSelected(AdapterView<? extends Obejct> parent) {
						// well... do nothing
					}
				});
			}
		
			private void addListenerToSpinnerPriority() {
				spinnerPriority.setOnItemSelectedListener(new OnItemSelectedListener() {
					public void onItemSelected(AdapterView<? extends Object> parent, View view, int pos, long id) {
						selectedPriority = (Priority) parent.getItemAtPosition(pos);
					}
		
					public void onNothingSelected(AdapterView<? extends Object> parent) {
						// well... do nothing
					}
				});
			}
		
			private void addListenerToBtnSave() {
				btnSave.setOnClickListener(new Button.OnClickListener() {
					public void onClick(View v) {
						try {
							Reminder reminder = createReminder();
							if (editingReminder) {
								reminder.setId(previewReminderId);
								Controller.instance(getApplicationContext()).updateReminder(reminder);
							} else {
								Controller.instance(getApplicationContext()).addReminder(reminder);
							}
							finish(); // Kills the activity
						} catch (Exception e) {
							Log.e("ReminderAddActivity", e.getMessage());
							e.printStackTrace();
						}
					}
		
				});
			}
		
			private void addListenerToBtnCancel() {
				btnCancel.setOnClickListener(new Button.OnClickListener() {
					public void onClick(View v) {
						finish();
					}
				});
			}
		
			/*
			 * Just an auxiliary method to create reminders from the UI data.
			 * 
			 * @return a new reminder.
			 */
			private Reminder createReminder() {
				/*
				 * Since view's not passing all the information yet (priority ...), we
				 * instantiate a reminder initially passing only "text" and "date".
				 */
				Reminder reminder = new Reminder();
				try {
					reminder.setText(edtReminder.getText().toString());
					reminder.setDetails(edtDetails.getText().toString());
					reminder.setDate(edtDate.getText().toString());
					reminder.setHour(edtHour.getText().toString());
					reminder.setCategory(selectedCategory);
					reminder.setPriority(selectedPriority);
				} catch (InvalidTextException e) {
					Toast.makeText(getApplicationContext(), "Texto invalido.", Toast.LENGTH_SHORT).show();
				} catch (InvalidDateException e) {
					Toast.makeText(getApplicationContext(), "Data invalida.", Toast.LENGTH_SHORT).show();
				} catch (InvalidHourException e) {
					Toast.makeText(getApplicationContext(), "Hora invalida.", Toast.LENGTH_SHORT).show();
				}
				return reminder;
			}
		
			/*
			 * This method is used to verify if it is an editing call and if it is gets
			 * the information of the reminder wanted to be updated and its id that will
			 * be used latter to update the Reminder from the Intent.
			 */
			private Reminder getExistingReminder() {
				Reminder reminder = null;
		
				Intent intent = getIntent();
				String action = intent.getAction();
				String type = intent.getType();
		
				// Gets the information from the intent if it is an edit call
				if (Intent.ACTION_SEND.equals(action) && "text/plain".equals(type)) {
					previewReminderId = intent.getLongExtra("id", 0);
					String text = intent.getStringExtra("text");
					String categoryName = intent.getStringExtra("category_name");
					String categoryId = intent.getStringExtra("category_id");
					String date = intent.getStringExtra("date");
					String hour = intent.getStringExtra("hour");
					String priority = intent.getStringExtra("priority");
		
					reminder = new Reminder();
					reminder.setText(text);
					reminder.setPriority(Priority.fromCode(Integer.parseInt(priority, 10)));
					Category category = new Category();
					category.setName(categoryName);
					category.setId(Long.parseLong(categoryId));
					reminder.setCategory(category);
					reminder.setDate(date);
					reminder.setHour(hour);
					reminder.setId(previewReminderId);
				}
		
				return reminder;
			}
		
			/*
			 * Integration code (with another apps).
			 * 
			 * The code below handles incoming requests from external apps which wants
			 * to add a reminder (eg.: Users may want to add a reminder for a TV program
			 * which they're seeing in GuiaTV app).
			 */
			private Reminder getReminderFromIntent() {
				Intent intent = getIntent();
				String action = intent.getAction();
				String type = intent.getType();
		
				/*
				 * External apps which wants to share content with "Lembretes" must
				 * follow the protocol described by the "if" below, that is, they must
				 * instantiate an intent and set:
				 * 
				 * ACTION as "br.com.positivo.reminders.ADD_REMINDER"; MIME as
				 * "text/plain";
				 * 
				 * and pass the contents through "putExtra" in the following fields:
				 * "text", "details", "category", "date", "hour" and "priority".
				 */
				if ("br.com.positivo.reminders.ADD_REMINDER".equals(action) && "text/plain".equals(type)) {
					try {
						String text = intent.getStringExtra("text");
						String details = intent.getStringExtra("details");
						String category = intent.getStringExtra("category");
						String date = intent.getStringExtra("date");
						String hour = intent.getStringExtra("hour");
						String priority = intent.getStringExtra("priority");
		
						/*
						 * Code below just validates the data supplied, since validation
						 * code is implemented in setter methods.
						 */
		
						// Would we better apply validations here?
						Reminder reminder = new Reminder();
						reminder.setText(text);
						reminder.setDetails(details);
		
						Category auxCategory = new Category();
						auxCategory.setName(category);
						reminder.setCategory(auxCategory);
		
						reminder.setDate(date);
						reminder.setHour(hour);
		
						/*
						 * Upon here, all validations were applied and we have a valid
						 * reminder. So, we return it.
						 */
						return reminder;
					} catch (InvalidFormatException e) {
						/*
						 * What would be better? 1. Return user to the calling activity.
						 * 2. Show an empty reminder's add form (implemented now).
						 */
					}
				}
				/*
				 * If this activity was not started from an external app or a valid
				 * reminder could not be derived, we simply return "null".
				 */
				return null;
			}
		
			/*
			 * Initializes the view.
			 * 
			 * This method just initializes the form for adding a new reminder. If a
			 * reminder object is supplied, "initialize" pre-populates the form with
			 * that content.
			 */
			private void initialize(Reminder reminder) {
				try {
					edtReminder = (EditText) findViewById(R.id.edtReminder);
		
					edtDetails = (EditText) findViewById(R.id.edtDetails);
		
					// edtDate = (EditText) findViewById(R.id.edtDate);
					// edtDate.addTextChangedListener(Mask.insert("##-##-####",
					// edtDate));
		
					// edtHour = (EditText) findViewById(R.id.edtHour);
					// edtHour.addTextChangedListener(Mask.insert("##:##", edtHour));
		
					spinnerPriority = getSpinnerPriority();
		
					spinnerCategory = getSpinnerCategory();
		
					if (reminder != null) {
						updateFieldsFromReminder(reminder);
					}
		
					btnSave = (Button) findViewById(R.id.btnSave);
					btnCancel = (Button) findViewById(R.id.btnCancel);
				} catch (Exception e) {
					// TODO: we really need to think about our exception handling
					// approach
					e.printStackTrace();
				}
			}
		
			private void updateFieldsFromReminder(Reminder reminder) throws Exception {
				edtReminder.setText(reminder.getText());
				edtDetails.setText(reminder.getDetails());
				edtDate.setText(reminder.getDate());
				edtHour.setText(reminder.getHour());
				spinnerPriority.setSelection(reminder.getPriority());
				spinnerCategory.setSelection(categoryToIndex(reminder.getCategory()));
			}
		
			private Spinner getSpinnerCategory() throws Exception {
				Spinner spinner = (Spinner) findViewById(R.id.spinnerCategories);
		
				SpinnerAdapterGenerator<Category> adapterCategoryGenerator = new SpinnerAdapterGenerator<Category>();
		
				List<Category> categories = Controller.instance(getApplicationContext()).listCategories();
		
				spinner.setAdapter(adapterCategoryGenerator.getSpinnerAdapter(categories, this));
		
				return spinner;
			}
		
			private Spinner getSpinnerPriority() {
				Spinner spinner = (Spinner) findViewById(R.id.spinnerPriorities);
		
				SpinnerAdapterGenerator<Priority> adapterPriorityGenerator = new SpinnerAdapterGenerator<Priority>();
		
				List<Priority> priorityValues = Arrays.asList(Priority.values());
		
				ArrayAdapter<Priority> priorityArrayAdapter = adapterPriorityGenerator.getSpinnerAdapter(priorityValues, this);
		
				spinner.setAdapter(priorityArrayAdapter);
		
				spinner.setSelection(Priority.NORMAL.getCode());
		
				return spinner;
			}
		
			private int categoryToIndex(Category category) throws Exception {
				List<Category> categories = Controller.instance(getApplicationContext()).listCategories();
				int i = 0;
				for (Category c : categories) {
					if (c.getName().equals(category.getName())) {
						return i;
					}
					i++;
				}
				return 0;
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.view;
		
		import java.util.Calendar;
		import java.util.GregorianCalendar;
		import java.util.List;
		
		import android.content.Context;
		import android.graphics.Color;
		import android.graphics.Typeface;
		import android.view.LayoutInflater;
		import android.view.View;
		import android.view.ViewGroup;
		import android.widget.ArrayAdapter;
		import android.widget.CheckBox;
		import android.widget.CompoundButton;
		import android.widget.ImageView;
		import android.widget.LinearLayout;
		import android.widget.TextView;
		import br.unb.cic.framework.persistence.DBException;
		import br.unb.cic.reminders.controller.Controller;
		import br.unb.cic.reminders.model.Reminder;
		import br.unb.cic.reminders2.R;
		
		public class ReminderArrayAdapter extends ArrayAdapter<Reminder> {
		
			private Context context;
		
			private int rowColor = Color.BLACK;// Used to change the row texts color
		
			// rowType: used to identify which type of row it might produce, once
			// that each one has a different way to show the Date, for example.
			private int rowType = NEXT_DAYS;
		
			// Type constants:
			public static final int LATE = 0;
			public static final int TODAY = 1;
			public static final int NEXT_DAYS = 2;
			public static final int NO_DATE = 3;
		
			/**
			 * This class is used in the parts of the view which is needed to list the
			 * reminders, as an adapter to these components listing the Reminders items.
			 * 
			 * @param context
			 *            , and the reminders objects(List<Reminders>).
			 * 
			 * @author positivo
			 * 
			 */
			public ReminderArrayAdapter(Context context, List<Reminder> objects) {
				super(context, R.layout.reminder_row, objects);
				this.context = context;
		
				this.rowColor = Color.BLACK;
				this.rowType = NEXT_DAYS;
			}
		
			public ReminderArrayAdapter(Context context, List<Reminder> objects, int rowColor, int rowType) {
				super(context, R.layout.reminder_row, objects);
				this.context = context;
		
				this.rowColor = rowColor;
				this.rowType = rowType;
			}
		
			@Override
			public View getView(int position, View convertView, ViewGroup parent) {
				LinearLayout reminderRow;
		
				// Inflate the row view
				if (convertView == null) {
					reminderRow = new LinearLayout(getContext());
					String inflater = Context.LAYOUT_INFLATER_SERVICE;
					LayoutInflater vi;
					vi = (LayoutInflater) getContext().getSystemService(inflater);
					vi.inflate(R.layout.reminder_row, reminderRow, true);
				} else {
					reminderRow = (LinearLayout) convertView;
				}
		
				// Takes the views included in the row
				ImageView ivPriority = (ImageView) reminderRow.findViewById(R.id.ivPriority);
				TextView tvReminder = (TextView) reminderRow.findViewById(R.id.txtReminder);
				TextView tvDateFirst = (TextView) reminderRow.findViewById(R.id.txtDateFirst);
				TextView tvDateSecond = (TextView) reminderRow.findViewById(R.id.txtDateSecond);
				CheckBox tvDone = (CheckBox) reminderRow.findViewById(R.id.cbDone);
				tvDone.setTag(position);
				tvDone.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
					public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
						try {
							Reminder reminder = getItem((Integer) buttonView.getTag());
							reminder.setDone(isChecked);
							Controller.instance(getContext()).updateReminder(reminder);
						} catch (DBException e) {
							e.printStackTrace();
						}
					}
				});
		
				// Fill the views with its contents
				// Fill the imageview based in the priority
				if (getItem(position).getPriority() == 1)
					ivPriority.setImageResource(R.drawable.important);
				else if (getItem(position).getPriority() == 2)
					ivPriority.setImageResource(R.drawable.urgent);
		
				tvReminder.setTextColor(rowColor);
				// if it is "Importante" or "Urgente" it might be bold!
				if (getItem(position).getPriority() != 0)
					tvReminder.setTypeface(null, Typeface.BOLD);
				tvReminder.setText(getItem(position).getText());
		
				// Based in the type of the row includes the specified date
				tvDateFirst.setTextColor(rowColor);
				tvDateFirst.setText(getDateFirst(position));
				tvDateSecond.setTextColor(rowColor);
				tvDateSecond.setText(getDateSecond(position));
		
				tvDone.setChecked(getItem(position).isDone());
		
				return reminderRow;
			}
		
			/**
			 * Used to get the DateFirst based in the rowType and proximity to the
			 * current date.
			 * 
			 * @param position
			 * @return
			 */
			private String getDateFirst(int position) {
		
				if (getItem(position).getDate() == null) {
					return "";
				}
		
				String months[] = { "JAN", "FEV", "MAR", "ABR", "MAI", "JUN", "JUL", "AGO", "SET", "OUT", "NOV", "DEZ" };
				String week[] = { "", "DOM", "SEG", "TER", "QUA", "QUI", "SEX", "SAB" };
		
				// Today and thatDay Calendars being initialized
				Calendar today = Calendar.getInstance();
				GregorianCalendar thatDay = new GregorianCalendar();
				thatDay.set(Integer.parseInt(getItem(position).getDate().substring(6, 10)), // year
						Integer.parseInt(getItem(position).getDate().substring(3, 5)) - 1, // month
						Integer.parseInt(getItem(position).getDate().substring(0, 2)));// day
		
				// switch based on the row type
				switch (rowType) {
				case LATE:
					long diff = today.getTimeInMillis() - thatDay.getTimeInMillis();
					long days = diff / (24*60*60*1000);
					if (days == 1)
						return "Ontem";
					else
						return "H " + days + " dias";
					// break;
		
				case TODAY:
					return getDatesHour(position);
				// break;
		
				case NEXT_DAYS:
					diff = thatDay.getTimeInMillis() - today.getTimeInMillis();
					days = diff / (24*60*60*1000);
		
					if (days == 1) {
						return getDatesHour(position);
					} else if (days < 6) {
						return week[thatDay.get(Calendar.DAY_OF_WEEK)];
					} else {
						return thatDay.get(Calendar.DAY_OF_MONTH) + " " + months[thatDay.get(Calendar.MONTH)];
					}
		
					// break;
		
				default:
					break;
				}
		
				return getItem(position).getDate();
		
			}
		
			/**
			 * Used to get the DateSecond based in the rowType
			 * 
			 * @param position
			 * @return
			 */
			private String getDateSecond(int position) {
		
				switch (rowType) {
				case LATE:
					return getDatesHour(position);
				// break;
				case TODAY:
					return "hoje";
				// break;
				case NEXT_DAYS:
					// Today and thatDay Calendars being initialized
					Calendar today = Calendar.getInstance();
					GregorianCalendar thatDay = new GregorianCalendar();
					thatDay.set(Integer.parseInt(getItem(position).getDate().substring(6, 10)), // year
							Integer.parseInt(getItem(position).getDate().substring(3, 5)) - 1, // month
							Integer.parseInt(getItem(position).getDate().substring(0, 2)));// day
		
					long diff = thatDay.getTimeInMillis() - today.getTimeInMillis();
					long days = diff / (24*60*60*1000);
		
					if (days == 1)
						return "amanha";
					else
						return getDatesHour(position);
					// break;
				default:
					break;
				}
		
				return getItem(position).getHour();
			}
		
			/**
			 * Gets the hour in the DateFirst/DateSecond format
			 * 
			 * @param position
			 * @return
			 */
			private String getDatesHour(int position) {
		
				if (getItem(position).getHour() == null) {
					return "";
				}
		
				if (getItem(position).getHour().substring(3, 5) != "00")
					return getItem(position).getHour().substring(0, 2) + "h" + getItem(position).getHour().substring(3, 5);
				else
					return getItem(position).getHour().substring(0, 2) + "h";
			}
		
			/**
			 * Get rowColor
			 * 
			 * @return
			 */
			public int getRowColor() {
				return rowColor;
			}
		
			/**
			 * Set rowColor
			 * 
			 * @param rowColor
			 */
			public void setRowColor(int rowColor) {
				this.rowColor = rowColor;
			}
		
			/**
			 * Get rowType
			 * 
			 * @return
			 */
			public int getRowType() {
				return rowType;
			}
		
			/**
			 * Set rowType
			 * 
			 * @param rowType
			 */
			public void setRowType(int rowType) {
				this.rowType = rowType;
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.view;
		
		import java.util.List;
		
		import android.content.Context;
		import android.view.LayoutInflater;
		import android.view.View;
		import android.view.ViewGroup;
		import android.widget.ArrayAdapter;
		import android.widget.LinearLayout;
		import android.widget.TextView;
		import br.unb.cic.reminders.controller.ReminderFilter;
		import br.unb.cic.reminders2.R;
		
		public class ReminderFilterArrayAdapter extends ArrayAdapter<ReminderFilter> {
		
			/**
			 * This class is used in the parts of the view which is needed to list the
			 * filters, as an adapter to these components listing the ReminderFilter
			 * items.
			 * 
			 * @author positivo
			 */
		
			public ReminderFilterArrayAdapter(Context context, List<ReminderFilter> objects) {
				super(context, R.layout.category_row, objects);
			}
		
			@Override
			public View getView(int position, View convertView, ViewGroup parent) {
				LinearLayout filterRow;
		
				// Inflate the view
				if (convertView == null) {
					filterRow = new LinearLayout(getContext());
					String inflater = Context.LAYOUT_INFLATER_SERVICE;
					LayoutInflater vi;
					vi = (LayoutInflater) getContext().getSystemService(inflater);
					vi.inflate(R.layout.category_row, filterRow, true);
				} else {
					filterRow = (LinearLayout) convertView;
				}
		
				TextView tvFilter = (TextView) filterRow.findViewById(R.id.row_categoryName);
				tvFilter.setText(getItem(position).getName());
		
				TextView tvNumReminders = (TextView) filterRow.findViewById(R.id.row_categoryCounter);
				tvNumReminders.setText(Integer.toString(getItem(position).getNumReminders()));
		
				return filterRow;
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.view;
		
		import java.util.ArrayList;
		import java.util.Calendar;
		import java.util.GregorianCalendar;
		import java.util.List;
		
		import util.Utility;
		import android.app.Fragment;
		import android.content.Intent;
		import android.graphics.Color;
		import android.os.Bundle;
		import android.util.Log;
		import android.view.ContextMenu;
		import android.view.ContextMenu.ContextMenuInfo;
		import android.view.MenuInflater;
		import android.view.MenuItem;
		import android.view.View;
		import android.view.ViewGroup;
		import android.widget.AdapterView;
		import android.widget.ListView;
		import br.unb.cic.framework.persistence.DBException;
		import br.unb.cic.reminders.controller.AllRemindersFilter;
		import br.unb.cic.reminders.controller.Controller;
		import br.unb.cic.reminders.controller.ReminderFilter;
		import br.unb.cic.reminders.model.Reminder;
		import br.unb.cic.reminders2.R;
		
		public class ReminderListFragment extends Fragment implements FiltersListChangeListener {
		
			private static String TAG = "reminder fragment list";
		
			private ListView lvReminderLate, lvReminderToday, lvReminderNextDays, lvReminderNoDate;
			private ReminderArrayAdapter adapter;
		
			// Used to keep the adapter of the listview that called the context menu:
			private ReminderArrayAdapter contextMenuAdapter;
		
			// Used to reference the interface views to the code in the createUI():
			private View view;
		
			/**
			 * Called when the activity is first created by the activity.
			 * 
			 * @param savedInstanceState
			 *            If the activity is being re-initialized after previously being
			 *            shut down then this Bundle contains the data it most recently
			 *            supplied in onSaveInstanceState(Bundle). <b>Note: Otherwise it
			 *            is null.</b>
			 */
			@Override
			public View onCreateView(android.view.LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
				super.onCreate(savedInstanceState);
				Log.i(TAG, "onCreate");
				view = inflater.inflate(R.layout.reminders_list_fragment, container, false);
				createUI();
				return view;
			}
		
			/**
			 * onResume method used to update the activity.
			 */
			@Override
			public void onResume() {
				super.onResume();
				updateListView(null);
			}
		
			/**
			 * Creates the context menu where shows the Edit and Delete options.
			 */
			// @Override
			public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
				super.onCreateContextMenu(menu, v, menuInfo);
		
				// Save the adapter which created this context menu:
				ListView view = (ListView) v;
				contextMenuAdapter = (ReminderArrayAdapter) view.getAdapter();
		
				menu.setHeaderTitle(R.string.context_menu_reminder_title);
		
				MenuInflater inflater = getActivity().getMenuInflater();
				inflater.inflate(R.menu.reminder_list_fragment_context_menu, menu);
			}
		
			/**
			 * Provides each action based in the chosen option(Edit or Delete).
			 */
			@Override
			public boolean onContextItemSelected(MenuItem item) {
				if (item.getGroupId() == R.id.context_menu_reminder) { // Used to verify
					// if it is the right context_menu
		
					// Gets the item position and gets the reminder in that position:
					AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
					Reminder reminder = (Reminder) contextMenuAdapter.getItem(info.position);
		
					// Switch between the options in the context menu(Edit, Delete and
					// Share)
					switch (item.getItemId()) {
					case R.id.edit:
						// Passes the current reminder to be edited via Intent and
						// Invokes edit method
						Intent editIntent = new Intent(getActivity().getApplicationContext(), EditReminderActivity.class);
						editIntent.putExtra("id", reminder.getId());
						editIntent.putExtra("text", reminder.getText());
						editIntent.putExtra("details", reminder.getDetails());
						editIntent.putExtra("category_name", reminder.getCategory().getName());
						editIntent.putExtra("category_id", Long.toString(reminder.getCategory().getId()));
						editIntent.putExtra("date", reminder.getDate());
						editIntent.putExtra("hour", reminder.getHour());
						editIntent.putExtra("priority", Integer.toString(reminder.getPriority()));
						startActivity(editIntent);
						updateListView(null);
						return true;
					case R.id.delete:
						// Invokes delete method
						try {// Deletes from the bank;
							Controller.instance(getActivity().getApplicationContext()).deleteReminder(reminder);
						} catch (DBException e) {
							Log.e(TAG, e.getMessage());
						}
						updateListView(null);
						return true;
					default:
						return super.onContextItemSelected(item);
					}
		
				}
				return super.onContextItemSelected(item);
			}
		
			/**
			 * Creates the User Interface.
			 **/
			public void createUI() {
				// Take the ListView view form the layout and apply the
				// ReminderArrayAdapter to it
				lvReminderLate = (ListView) view.findViewById(R.id.lvRemindersLate);
				lvReminderToday = (ListView) view.findViewById(R.id.lvRemindersToday);
				lvReminderNextDays = (ListView) view.findViewById(R.id.lvRemindersNextDays);
				lvReminderNoDate = (ListView) view.findViewById(R.id.lvRemindersNoDate);
				updateListView(null);
				registerForContextMenu(lvReminderLate);
				registerForContextMenu(lvReminderToday);
				registerForContextMenu(lvReminderNextDays);
				registerForContextMenu(lvReminderNoDate);
			}
		
			/**
			 * Updates the ListView with the current reminders.
			 */
			public void updateListView(ReminderFilter filter) {
				if (filter == null)
					filter = new AllRemindersFilter(getActivity());
				adapter = new ReminderArrayAdapter(getActivity().getApplicationContext(), filter.getReminderList());
		
				// Divide the adapter in 4 possibilities of dates(Late, Today, Next Days
				// and No Date)
				// and distribute it to each responsible ListView:
				ReminderArrayAdapter adapterLate, adapterToday, adapterNextDays, adapterNoDate;
		
				Reminder r = new Reminder();
				List<Reminder> remindersLate = new ArrayList<Reminder>();
				List<Reminder> remindersToday = new ArrayList<Reminder>();
				List<Reminder> remindersNextDays = new ArrayList<Reminder>();
				List<Reminder> remindersNoDate = new ArrayList<Reminder>();
		
				// Runs through the adapter and divides to the correspondent adapter
				for (int i = 0; i < adapter.getCount(); ++i) {
					r = adapter.getItem(i);
					if (r.getDate() != null) {
						String day = r.getDate().substring(0, 2);
						String month = r.getDate().substring(3, 5);
						String year = r.getDate().substring(6, 10);
		
						Calendar cal = Calendar.getInstance();
						GregorianCalendar gc = new GregorianCalendar();
						if (r.getHour() != null) {
							String hour = r.getHour().substring(0, 2);
							String min = r.getHour().substring(3, 5);
							gc.set(Integer.parseInt(year), Integer.parseInt(month) - 1, Integer.parseInt(day),
									Integer.parseInt(hour), Integer.parseInt(min));
						} else {
							gc.set(Integer.parseInt(year), Integer.parseInt(month) - 1, Integer.parseInt(day));
						}
						// if(Integer.parseInt(day)<cal.get(Calendar.DAY_OF_MONTH))
						if (gc.before(cal))
							remindersLate.add(r);
						else if ((cal.get(Calendar.YEAR) == gc.get(Calendar.YEAR))
								&& (cal.get(Calendar.MONTH) == gc.get(Calendar.MONTH))
								&& (cal.get(Calendar.DAY_OF_MONTH) == gc.get(Calendar.DAY_OF_MONTH)))
							remindersToday.add(r);
						else
							remindersNextDays.add(r);
					} else {
						remindersNoDate.add(r);
					}
				}
		
				// Creates each adapter:
				adapterLate = new ReminderArrayAdapter(getActivity().getApplicationContext(), remindersLate,
						Color.rgb(0xED, 0x1C, 0x24), ReminderArrayAdapter.LATE);
				adapterToday = new ReminderArrayAdapter(getActivity().getApplicationContext(), remindersToday,
						Color.rgb(0x33, 0xB5, 0xE5), ReminderArrayAdapter.TODAY);
				adapterNextDays = new ReminderArrayAdapter(getActivity().getApplicationContext(), remindersNextDays,
						Color.rgb(0x99, 0x99, 0x99), ReminderArrayAdapter.NEXT_DAYS);
				adapterNoDate = new ReminderArrayAdapter(getActivity().getApplicationContext(), remindersNoDate,
						Color.rgb(0x00, 0x00, 0x00), ReminderArrayAdapter.NO_DATE);
		
				// Apply the adapters and rearrange the ListViews to its contents size:
				lvReminderLate.setAdapter(adapterLate);
				Utility.setListViewHeightBasedOnChildren(lvReminderLate);
				lvReminderToday.setAdapter(adapterToday);
				Utility.setListViewHeightBasedOnChildren(lvReminderToday);
				lvReminderNextDays.setAdapter(adapterNextDays);
				Utility.setListViewHeightBasedOnChildren(lvReminderNextDays);
				lvReminderNoDate.setAdapter(adapterNoDate);
				Utility.setListViewHeightBasedOnChildren(lvReminderNoDate);
			}
		
			public void onSelectedFilterChanged(ReminderFilter filter) {
				updateListView(filter);
			}
		}
	}
	adds {
		package br.unb.cic.reminders.view;
		
		import java.util.Iterator;
		
		import android.content.Context;
		import android.widget.ArrayAdapter;
		import br.unb.cic.reminders2.R;
		
		public class SpinnerAdapterGenerator<T> {
		
			public ArrayAdapter<T> getSpinnerAdapter(Iterable<T> items, Context context) {
		
				// create an empty adapter
				ArrayAdapter<T> adapter = new ArrayAdapter<T>(context.getApplicationContext(), R.layout.spinner_item);
				adapter.setDropDownViewResource(R.layout.spinner_dropdown_item);
		
				if (items != null && items.iterator().hasNext()) {
					Iterator<T> it = items.iterator();
					while (it.hasNext()) {
						adapter.add(it.next());
					}
				}
		
				return adapter;
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.view;
		
		import java.util.Calendar;
		
		import android.app.Dialog;
		import android.app.DialogFragment;
		import android.app.TimePickerDialog;
		import android.content.DialogInterface;
		import android.os.Bundle;
		import android.widget.ArrayAdapter;
		import android.widget.Spinner;
		import android.widget.TimePicker;
		
		class TimePickerDialogFragment extends DialogFragment implements TimePickerDialog.OnTimeSetListener {
		
			private Calendar time;
		
			private Spinner spinnerTime;
		
			private int pHour;
			private int pMinute;
		
			public TimePickerDialogFragment(Calendar date, Spinner spinnerTime) {
				this.time = date;
				this.spinnerTime = spinnerTime;
			}
		
			@Override
			public Dialog onCreateDialog(Bundle savedInstanceState) {
				// Use the current date as the default date in the picker
				int hour = time.get(Calendar.HOUR_OF_DAY);
				int minute = time.get(Calendar.MINUTE);
		
				// Create a new instance of DatePickerDialog and return it
				return new TimePickerDialog(getActivity(), this, hour, minute, true);
			}
		
			@SuppressWarnings("unchecked")
			@Override
			public void onDismiss(DialogInterface dialog) {
				time.set(Calendar.MINUTE, pMinute);
				time.set(Calendar.HOUR_OF_DAY, pHour);
				String sTime = Integer.toString(pMinute);
				if (pMinute < 10)
					sTime = "0" + sTime;
				sTime = Integer.toString(pHour) + ":" + sTime;
		
				ArrayAdapter<String> adapter = (ArrayAdapter<String>) spinnerTime.getAdapter();
				adapter.add(sTime);
				spinnerTime.setSelection(2);
		
				super.onDismiss(dialog);
			}
		
			public void onTimeSet(TimePicker view, int hour, int minute) {
				pHour = hour;
				pMinute = minute;
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.controller;

		import android.content.Context;
		import br.unb.cic.reminders.model.Reminder;

		public class AllRemindersFilter extends ReminderFilter {

			private final String name = "Todos";

			public AllRemindersFilter(Context context) {
				super(context);
			}

			@Override
			protected boolean selectReminder(Reminder r) {
				return true;
			}

			@Override
			public String getName() {
				return name;
			}

		}
	}
	adds {
		package br.unb.cic.reminders.controller;

		import android.content.Context;
		import br.unb.cic.reminders.model.Category;
		import br.unb.cic.reminders.model.Reminder;

		public class CategoryFilter extends ReminderFilter {

			private Category category;

			public CategoryFilter(Category category, Context context) {
				super(context);
				this.category = category;
			}

			@Override
			protected boolean selectReminder(Reminder r) {
				return r.getCategory().getName().equals(category.getName());
			}

			public Category getCategory() {
				return category;
			}

			@Override
			public String getName() {
				return category.getName();
			}

		}	
	}
	adds {
		package br.unb.cic.reminders.controller;

		import android.content.Context;
		import br.unb.cic.reminders.model.Priority;
		import br.unb.cic.reminders.model.Reminder;

		public class PriorityFilter extends ReminderFilter {

			private Priority priority;

			public PriorityFilter(Priority priority, Context context) {
				super(context);
				this.priority = priority;
			}

			@Override
			protected boolean selectReminder(Reminder r) {
				return r.getPriority() == priority.getCode();
			}

			@Override
			public String getName() {
				return priority.toString();
			}

		}
	}
	adds {
		package br.unb.cic.reminders.controller;

		import java.util.ArrayList;
		import java.util.List;

		import android.content.Context;
		import br.unb.cic.reminders.model.Reminder;

		public abstract class ReminderFilter {

			private List<Reminder> reminders;
			private Context context;

			public ReminderFilter(Context context) {
				this.context = context;
			}

			public List<Reminder> getReminderList() {
				updateReminders();
				return reminders;
			}

			public int getNumReminders() {
				updateReminders();
				return reminders.size();
			}

			private void updateReminders() {
				reminders = new ArrayList<Reminder>();
				List<Reminder> allReminders = null;

				try {
					// Get all reminders
					allReminders = Controller.instance(context).listReminders();
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				// Filter the reminders
				for (Reminder r : allReminders) {
					if (selectReminder(r)) {
						reminders.add(r);
					}
				}
			}

			abstract protected boolean selectReminder(Reminder r);

			abstract public String getName();
		}
	}
	adds {
		package br.unb.cic.reminders.model;
		
		import java.util.regex.Matcher;
		import java.util.regex.Pattern;
		
		import util.Patterns;
		import br.unb.cic.framework.persistence.DBTypes;
		import br.unb.cic.framework.persistence.annotations.Column;
		import br.unb.cic.framework.persistence.annotations.Entity;
		import br.unb.cic.framework.persistence.annotations.ForeignKey;
		import br.unb.cic.reminders.view.InvalidHourException;
		
		/**
		 * This class provides basic representation of a reminder.
		 * 
		 * @author rbonifacio
		 */
		@Entity(table = "REMINDER")
		public class Reminder {
		
			@Column(column = "PK", primaryKey = true, type = DBTypes.LONG)
			private Long id;
		
			@Column(column = "TEXT", type = DBTypes.TEXT)
			private String text;
		
			@Column(column = "DETAILS", type = DBTypes.TEXT)
			private String details;
		
			@Column(column = "FK_CATEGORY", type = DBTypes.LONG)
			@ForeignKey(mappedBy = "id")
			private Category category;
		
			@Column(column = "DATE", type = DBTypes.TEXT)
			private String date; // it must be in the YYYY-MM-DD format
		
			@Column(column = "HOUR", type = DBTypes.TEXT)
			private String hour; // it must be in the HH:mm format
		
			@Column(column = "PRIORITY", type = DBTypes.INT)
			private Priority priority;
		
			@Column(column = "DONE", type = DBTypes.INT)
			private boolean done;
		
			public Reminder() {
			}
		
			public Reminder(Long id, String text) {
				this.id = id;
				this.text = text;
			}
		
			public Long getId() {
				return id;
			}
		
			public void setId(Long id) {
				this.id = id;
			}
		
			public String getText() {
				return text;
			}
		
			public void setText(String text) {
				if (text == null || text.trim().equals("")) {
					throw new InvalidTextException(text);
				}
				this.text = text;
			}
		
			public String getDetails() {
				return details;
			}
		
			public void setDetails(String details) {
				// Details are optional.
				if (details == null || details.trim().equals("")) {
					this.details = null;
				} else {
					this.details = details;
				}
			}
		
			public Category getCategory() {
				return category;
			}
		
			public void setCategory(Category category) {
				this.category = category;
			}
		
			public String getDate() {
				return date;
			}
		
			public void setDate(String date) {
				// We allow reminders to have no date associated.
				if (!(date == null || date.equals("")) && !checkFormat(date, Patterns.DATE_PATTERN)) {
					throw new InvalidDateException(date);
				}
				this.date = date;
			}
		
			public String getHour() {
				return hour;
			}
		
			public void setHour(String hour) {
				// We allow reminders to have no hour associated.
				if (!(hour == null || hour.equals("")) && !checkFormat(hour, Patterns.HOUR_PATTERN)) {
					throw new InvalidHourException(hour);
				}
				this.hour = hour;
			}
		
			private boolean checkFormat(String date, String pattern) {
				Pattern p = Pattern.compile(pattern);
				Matcher m = p.matcher(date);
				return m.matches();
			}
		
			public int getPriority() {
				return priority.getCode();
			}
		
			public void setPriority(Priority priority) {
				this.priority = priority;
			}
		
			public boolean isValid() {
				return (text != null && category != null && date != null && hour != null && priority != null);
			}
		
			public boolean isDone() {
				return done;
			}
		
			public void setDone(boolean done) {
				this.done = done;
			}
		
			/* DB getter & setter */
			public int getDone() {
				return done ? 1 : 0;
			}
		
			public void setDone(int done) {
				this.done = (done == 0 ? false : true);
			}
		
		}
	}
	adds {
		package br.unb.cic.reminders.model;
		
		import br.unb.cic.framework.persistence.DBTypes;
		import br.unb.cic.framework.persistence.annotations.Column;
		import br.unb.cic.framework.persistence.annotations.Entity;
		
		/**
		 * This class represents a categegory, an useful abstraction for classifying
		 * reminders.
		 * 
		 * @author rbonifacio
		 */
		@Entity(table = "CATEGORY")
		public class Category {
			@Column(column = "PK", type = DBTypes.LONG, primaryKey = true)
			private Long id;
		
			@Column(column = "NAME", type = DBTypes.TEXT)
			private String name;
		
			@Column(column = "LOCKED", type = DBTypes.INT)
			private int locked;
		
			public Category() {
			}
		
			public Category(Long id, String name) {
				this.id = id;
				this.name = name;
				this.locked = 0;
			}
		
			public Category(Long id, String name, int locked) {
				this.id = id;
				this.name = name;
				this.locked = locked;
			}
		
			public Long getId() {
				return id;
			}
		
			public void setId(Long id) {
				this.id = id;
			}
		
			public String getName() {
				return name;
			}
		
			public void setName(String name) {
				if (name.isEmpty() == true)
					throw new InvalidTextException(name);
				else
					this.name = name;
			}
		
			public int getLocked() {
				return locked;
			}
		
			public void setLocked(int locked) {
				this.locked = locked;
			}
		
			@Override
			public String toString() {
				return name;
			}
		}
	}
	adds {
		package br.unb.cic.reminders.model.db;
		
		public class DBConstants {
			public static String DROP_TABLE_STATEMENTS[] = { "DROP TABLE IF EXISTS REMINDER", "DROP TABLE IF EXISTS CATEGORY" };
		
			public static String CREATE_TABLE_STATEMENTS[] = { "CREATE TABLE CATEGORY("
					+ "PK INTEGER PRIMARY KEY AUTOINCREMENT, " + "NAME VARCHAR(50) NOT NULL, " + "LOCKED INT NOT NULL);",
		
					"CREATE TABLE REMINDER ( " + "PK INTEGER PRIMARY KEY AUTOINCREMENT, " + "TEXT VARCHAR(50) NOT NULL,"
							+ "DETAILS VARCHAR(50) NULL,"
							+ "FK_CATEGORY INTEGER NOT NULL REFERENCES CATEGORY ON DELETE CASCADE," + "DATE CHAR(10) NULL,"
							+ "HOUR CHAR(5) NULL," + "PRIORITY INTEGER NOT NULL," + "DONE INTEGER NOT NULL);", };
		
			public static final String SELECT_CATEGORIES = "SELECT PK, NAME FROM CATEGORY";
			public static final String SELECT_CATEGORY_BY_NAME = "SELECT PK, NAME FROM CATEGORY WHERE NAME = ?";
			public static final String SELECT_CATEGORY_BY_ID = "SELECT PK, NAME FROM CATEGORY WHERE PK = ?";
		
			public static final String SELECT_REMINDERS = "SELECT PK, TEXT, DETAILS, FK_CATEGORY, DATE, HOUR, PRIORITY, DONE FROM REMINDER";
			public static final String SELECT_REMINDERS_BY_CATEGORY = "SELECT PK, TEXT, DETAILS, FK_CATEGORY, DATE, HOUR, PRIORITY, DONE FROM REMINDER WHERE FK_CATEGORY = ?";
		
			public static String DELETE_CATEGORIES = "DELETE FROM CATEGORY WHERE PK = ?";
		
			public static final String PREDEFINED_CATEGORIES[] = { "INSERT INTO CATEGORY VALUES (NULL,'Faculdade',1);",
					"INSERT INTO CATEGORY VALUES (NULL,'Trabalho',1);", "INSERT INTO CATEGORY VALUES (NULL,'Pessoal',1);" };
		
			public static String CATEGORY_TABLE = "CATEGORY";
			public static String CATEGORY_PK_COLUMN = "PK";
			public static String CATEGORY_NAME_COLUMN = "NAME";
			public static String CATEGORY_LOCKED_COLUMN = "LOCKED";
		
			public static String REMINDER_TABLE = "REMINDER";
			public static String REMINDER_PK_COLUMN = "PK";
			public static String REMINDER_TEXT_COLUMN = "TEXT";
			public static String REMINDER_DETAILS_COLUMN = "DETAILS";
			public static String REMINDER_FK_CATEGORY_COLUMN = "FK_CATEGORY";
			public static String REMINDER_DATE_COLUMN = "DATE";
			public static String REMINDER_HOUR_COLUMN = "HOUR";
			public static String REMINDER_PRIORITY_COLUMN = "PRIORITY";
			public static String REMINDER_DONE_COLUMN = "DONE";
		
		}
		
	}
	adds {
		package br.unb.cic.reminders.model.db;
		
		import android.content.Context;
		
		/**
		 * An abstract factory class to instantiate DAOs.
		 * 
		 * @author rbonifacio
		 */
		public abstract class DBFactory {
			protected Context context;
		
			public static DBFactory factory(Context context) {
				return new DefaultDBFactory(context);
			}
		
			/**
			 * DBFactory constructor
			 * 
			 * @param context
			 *            the application context.
			 */
			public DBFactory(Context context) {
				this.context = context;
			}
		
			/**
			 * Returns an instance of CategoryDAO.
			 * 
			 * @return an instance of CategoryDAO.
			 */
			public abstract CategoryDAO createCategoryDAO();
		
			/**
			 * Returns an instance of ReminderDAO.
			 * 
			 * @return an instance of ReminderDAO
			 */
			public abstract ReminderDAO createReminderDAO();
		}
	}
	adds {
		package br.unb.cic.reminders.model.db;

		import android.content.Context;

		/**
		 * A default implementation of the abstract class DBFactory.
		 *
		 * @author rbonifacio
		 */
		public class DefaultDBFactory extends DBFactory {

			public DefaultDBFactory(Context context) {
				super(context);
			}

			@Override
			public CategoryDAO createCategoryDAO() {
				return new DefaultCategoryDAO(context);
			}

			@Override
			public ReminderDAO createReminderDAO() {
				return new DefaultReminderDAO(context);
			}
		}
		
	}
	adds {
		package br.unb.cic.reminders.model.cp;
		
		import android.content.ContentProvider;
		import android.content.ContentValues;
		import android.content.UriMatcher;
		import android.database.Cursor;
		import android.net.Uri;
		import br.unb.cic.framework.persistence.DBException;
		import br.unb.cic.reminders.model.Category;
		import br.unb.cic.reminders.model.Reminder;
		import br.unb.cic.reminders.model.db.CategoryDAO;
		import br.unb.cic.reminders.model.db.DBConstants;
		import br.unb.cic.reminders.model.db.DefaultDBFactory;
		import br.unb.cic.reminders.model.db.ReminderDAO;
		
		/**
		 * A content provider for the Reminders database.
		 * 
		 * @author rbonifacio
		 */
		public class ReminderContentProvider extends ContentProvider {
		
			private static final int REMINDERS = 10;
		
			private static final String SECURITY_EXCEPTION = "You are not allowed to call this method";
		
			private static final String AUTHORITY = "br.com.positivo.reminders.contentprovider";
			private static final String BASE_PATH = "reminders";
		
			public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/" + BASE_PATH);
		
			public static final String category() {
				return DBConstants.CATEGORY_NAME_COLUMN;
			}
		
			public static final String text() {
				return DBConstants.REMINDER_TEXT_COLUMN;
			}
		
			public static final String date() {
				return DBConstants.REMINDER_DATE_COLUMN;
			}
		
			public static final String hour() {
				return DBConstants.REMINDER_HOUR_COLUMN;
			}
		
			private ReminderDAO rdao;
			private CategoryDAO cdao;
		
			// this is only relevant in the cases where we want to expose
			// access to more than one database table.
			private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
		
			static {
				sURIMatcher.addURI(AUTHORITY, BASE_PATH, REMINDERS);
			}
		
			@Override
			public boolean onCreate() {
				rdao = DefaultDBFactory.factory(getContext()).createReminderDAO();
				cdao = DefaultDBFactory.factory(getContext()).createCategoryDAO();
				return false;
			}
		
			@Override
			public Uri insert(Uri uri, ContentValues values) {
				try {
					Reminder reminder = new Reminder();
		
					Category category = cdao.findCategory(values.getAsString(category()));
		
					
					reminder.setCategory(category);
					reminder.setText(values.getAsString(text()));
					reminder.setDate(values.getAsString(date()));
					reminder.setHour(values.getAsString(hour()));
		
					Long id = rdao.saveReminder(reminder);
					getContext().getContentResolver().notifyChange(uri, null);
					return Uri.parse(BASE_PATH + "/" + id);
				} catch (DBException e) {
					throw new RuntimeException(e.getLocalizedMessage());
				}
		
			}
		
			@Override
			public Cursor query(Uri arg0, String[] arg1, String arg2, String[] arg3, String arg4) {
				// TODO Auto-generated method stub
				return null;
			}
		
			@Override
			/**
			 * An external application could not delete an existing reminder.
			 */
			public int delete(Uri arg0, String arg1, String[] arg2) {
				throw new SecurityException(SECURITY_EXCEPTION);
			}
		
			@Override
			/**
			 * It is not clear the rationale for this method. Most examples just return
			 * null.
			 */
			public String getType(Uri arg0) {
				return null;
			}
		
			@Override
			/**
			 * Ok, we also do not allow an externa application to update an existing
			 * reminder. A RuntimeException is thrown.
			 */
			public int update(Uri arg0, ContentValues arg1, String arg2, String[] arg3) {
				throw new SecurityException(SECURITY_EXCEPTION);
			}
		
		}
	}
}
